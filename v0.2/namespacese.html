<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>libse: se Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libse
   &#160;<span id="projectnumber">0.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">se Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Symbolic execution namespace.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacese_1_1tester"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacese_1_1tester.html">tester</a></td></tr>
<tr class="memdesc:namespacese_1_1tester"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test generator namespace. <br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_operator_info.html">OperatorInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static lookup function to find an operator's mathematical properties.  <a href="classse_1_1_operator_info.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_operator_info_3_01_n_o_t_01_4.html">OperatorInfo&lt; NOT &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_operator_info_3_01_a_d_d_01_4.html">OperatorInfo&lt; ADD &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_operator_info_3_01_l_a_n_d_01_4.html">OperatorInfo&lt; LAND &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_operator_info_3_01_l_o_r_01_4.html">OperatorInfo&lt; LOR &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_operator_info_3_01_e_q_l_01_4.html">OperatorInfo&lt; EQL &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_operator_info_3_01_l_s_s_01_4.html">OperatorInfo&lt; LSS &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_expr.html">Expr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for a symbolic expression such as "y = x + 7".  <a href="classse_1_1_expr.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_any_expr.html">AnyExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-safe symbolic variable of an arbitrary value.  <a href="classse_1_1_any_expr.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_value_expr.html">ValueExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-safe concrete value with an optional symbolic value.  <a href="classse_1_1_value_expr.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_cast_expr.html">CastExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type cast of another symbolic expression.  <a href="classse_1_1_cast_expr.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_unary_expr.html">UnaryExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator with one operand.  <a href="classse_1_1_unary_expr.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_if_then_else_expr.html">IfThenElseExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ternary expression of the form "x ? y : z".  <a href="classse_1_1_if_then_else_expr.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_nary_expr.html">NaryExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator with several operands.  <a href="classse_1_1_nary_expr.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_if.html">If</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control-flow annotation for multi-path symbolic execution of an if-then-else statement.  <a href="classse_1_1_if.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_interpreter.html">Interpreter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression evaluator.  <a href="classse_1_1_interpreter.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_sp_interpreter.html">SpInterpreter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strongest postcondition predicate transformer.  <a href="classse_1_1_sp_interpreter.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_unwinding_policy.html">UnwindingPolicy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unwinding semantics of a loop.  <a href="classse_1_1_unwinding_policy.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_bounded_unwinding_policy.html">BoundedUnwindingPolicy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounded loop unwinding semantics.  <a href="classse_1_1_bounded_unwinding_policy.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_loop.html">Loop</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control-flow annotation for multi-path symbolic execution of a loop statement.  <a href="classse_1_1_loop.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_tracer.html">Tracer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Path constraint manager.  <a href="classse_1_1_tracer.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_type_constructor.html">TypeConstructor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static type lookup table.  <a href="classse_1_1_type_constructor.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_type_constructor_3_01bool_01_4.html">TypeConstructor&lt; bool &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_type_constructor_3_01char_01_4.html">TypeConstructor&lt; char &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_type_constructor_3_01int_01_4.html">TypeConstructor&lt; int &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_abstract_value.html">AbstractValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for a (symbolic/concrete) lvalue.  <a href="classse_1_1_abstract_value.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>__any</b></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>__id</b></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_value.html">Value</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-safe (symbolic/concrete) lvalue.  <a href="classse_1_1_value.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_abstract_var.html">AbstractVar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for a (symbolic/concrete) lvalue.  <a href="classse_1_1_abstract_var.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_var.html">Var</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-safe (symbolic/concrete) rvalue.  <a href="classse_1_1_var.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_visitor.html">Visitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traversal algorithm for an acyclic directed graph (DAG)  <a href="classse_1_1_visitor.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_walker.html">Walker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acceptor in <a class="el" href="classse_1_1_visitor.html" title="Traversal algorithm for an acyclic directed graph (DAG)">Visitor</a> pattern.  <a href="classse_1_1_walker.html#details">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ab51adead44287e1acb1ea83d31c52144"><td class="memItemLeft" align="right" valign="top">typedef unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacese.html#ab51adead44287e1acb1ea83d31c52144">OperatorAttr</a></td></tr>
<tr class="memdesc:ab51adead44287e1acb1ea83d31c52144"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitmask to describe the mathematical properties of an operator.  <a href="#ab51adead44287e1acb1ea83d31c52144"></a><br/></td></tr>
<tr class="memitem:a594ed393deaf50eee0630623a84ab9bb"><td class="memItemLeft" align="right" valign="top">typedef std::shared_ptr&lt; <a class="el" href="classse_1_1_expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacese.html#a594ed393deaf50eee0630623a84ab9bb">SharedExpr</a></td></tr>
<tr class="memdesc:a594ed393deaf50eee0630623a84ab9bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vertex in the DAG which represents a symbolic expression.  <a href="#a594ed393deaf50eee0630623a84ab9bb"></a><br/></td></tr>
<tr class="memitem:a516238ac4bb4f8b557be2af2132aa883"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a516238ac4bb4f8b557be2af2132aa883"></a>
typedef std::runtime_error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacese.html#a516238ac4bb4f8b557be2af2132aa883">InterpreterException</a></td></tr>
<tr class="memdesc:a516238ac4bb4f8b557be2af2132aa883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsupported built-in C++ operation or primitive type. <br/></td></tr>
<tr class="memitem:a39a431ff182bfd5e6480bb197ca64f3a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a39a431ff182bfd5e6480bb197ca64f3a"></a>
typedef unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacese.html#a39a431ff182bfd5e6480bb197ca64f3a">Version</a></td></tr>
<tr class="memdesc:a39a431ff182bfd5e6480bb197ca64f3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Built-in unsigned numerical type which can be initialized to <a class="el" href="namespacese.html#affbbd1918df1e883dac205cdba1e63bf">VZERO</a>. <br/></td></tr>
<tr class="memitem:a57b5fe663697ba6989ddb11f13122c94"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a57b5fe663697ba6989ddb11f13122c94"></a>
typedef <a class="el" href="classse_1_1_var.html">Var</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Bool</b></td></tr>
<tr class="memitem:a0b8ed2f1170a74dfd89d1b5c7a35ba08"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b8ed2f1170a74dfd89d1b5c7a35ba08"></a>
typedef <a class="el" href="classse_1_1_var.html">Var</a>&lt; char &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Char</b></td></tr>
<tr class="memitem:a29fddc6be72db7677b6d28edc73fe739"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29fddc6be72db7677b6d28edc73fe739"></a>
typedef <a class="el" href="classse_1_1_var.html">Var</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Int</b></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:acdd644613b7c848c7f6e7e02e0f3029d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacese.html#acdd644613b7c848c7f6e7e02e0f3029d">OperatorAttrBit</a> { <br/>
&#160;&#160;<a class="el" href="namespacese.html#acdd644613b7c848c7f6e7e02e0f3029da3db99f785499929d65ef9d713bcbc4c0">CLEAR_ATTR</a> =  0u, 
<a class="el" href="namespacese.html#acdd644613b7c848c7f6e7e02e0f3029daead562a73585b2121d0e24a8a801576d">LASSOC_ATTR</a> =  (1u &lt;&lt; 2), 
<a class="el" href="namespacese.html#acdd644613b7c848c7f6e7e02e0f3029da83b0d160857aff077e9513160169ccc0">RASSOC_ATTR</a> =  (1u &lt;&lt; 1), 
<a class="el" href="namespacese.html#acdd644613b7c848c7f6e7e02e0f3029da7c6831cfc8632d333b20faa1aa8a2058">COMM_ATTR</a> =  (1u &lt;&lt; 3), 
<br/>
&#160;&#160;<a class="el" href="namespacese.html#acdd644613b7c848c7f6e7e02e0f3029dae0fbde84870b0821f683bd4ff6ca4593">HAS_ID_ELEMENT_ATTR</a> =  (1u &lt;&lt; 4)
<br/>
 }</td></tr>
<tr class="memdesc:acdd644613b7c848c7f6e7e02e0f3029d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit vector to define and inspect an operator's mathematical properties.  <a href="namespacese.html#acdd644613b7c848c7f6e7e02e0f3029d">More...</a><br/></td></tr>
<tr class="memitem:a7970802251b211c565f656366346d60f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacese.html#a7970802251b211c565f656366346d60f">Type</a> { <a class="el" href="namespacese.html#a7970802251b211c565f656366346d60fa87c78d3abab9c703d025dd7d12952b31">BOOL</a>, 
<a class="el" href="namespacese.html#a7970802251b211c565f656366346d60faf79133a9a225e1df662c7bc4ed1c6b8b">CHAR</a>, 
<a class="el" href="namespacese.html#a7970802251b211c565f656366346d60fa318b179bc8e33e9d34b00280873c3b4d">INT</a>
 }</td></tr>
<tr class="memdesc:a7970802251b211c565f656366346d60f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Built-in primitive types for which symbolic execution is supported.  <a href="namespacese.html#a7970802251b211c565f656366346d60f">More...</a><br/></td></tr>
<tr class="memitem:a9e4d2d07e23bdbb4cf63c4041f33639d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacese.html#a9e4d2d07e23bdbb4cf63c4041f33639d">Operator</a> { <br/>
&#160;&#160;<a class="el" href="namespacese.html#a9e4d2d07e23bdbb4cf63c4041f33639dafacbb2ef8d89bfcdbca19d4a3d8e9188">NOT</a>, 
<a class="el" href="namespacese.html#a9e4d2d07e23bdbb4cf63c4041f33639dac7cb225b609ddda8c036588cd89012a5">ADD</a>, 
<a class="el" href="namespacese.html#a9e4d2d07e23bdbb4cf63c4041f33639da8e844aa5bea1f00ebd5037ed57d805c8">LAND</a>, 
<a class="el" href="namespacese.html#a9e4d2d07e23bdbb4cf63c4041f33639dac0ad30ee11ab87674acec45b3fc0b87d">LOR</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacese.html#a9e4d2d07e23bdbb4cf63c4041f33639daeae77bf86710908e2d9fcd3a3714bed9">EQL</a>, 
<a class="el" href="namespacese.html#a9e4d2d07e23bdbb4cf63c4041f33639da3b1ad3a90356bfe8ea6fdea8de4f89ce">LSS</a>
<br/>
 }</td></tr>
<tr class="memdesc:a9e4d2d07e23bdbb4cf63c4041f33639d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Built-in C++ operators for which symbolic execution is supported.  <a href="namespacese.html#a9e4d2d07e23bdbb4cf63c4041f33639d">More...</a><br/></td></tr>
<tr class="memitem:a1daa21dcf920cc90f3cadba04672c648"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacese.html#a1daa21dcf920cc90f3cadba04672c648">ExprKind</a> { <br/>
&#160;&#160;<a class="el" href="namespacese.html#a1daa21dcf920cc90f3cadba04672c648ad9ebe1f0705856801b82ac4204db6598">ANY_EXPR</a>, 
<a class="el" href="namespacese.html#a1daa21dcf920cc90f3cadba04672c648a99877150257de5aa9b8a8befe788686f">VALUE_EXPR</a>, 
<a class="el" href="namespacese.html#a1daa21dcf920cc90f3cadba04672c648aacc93b779a93ab83b9613dee45748afd">CAST_EXPR</a>, 
<a class="el" href="namespacese.html#a1daa21dcf920cc90f3cadba04672c648ae7f0e9d072750a6b360935ad72cc133b">UNARY_EXPR</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacese.html#a1daa21dcf920cc90f3cadba04672c648a7924143d3b519e5a3f36027337c5a2a6">ITE_EXPR</a>, 
<a class="el" href="namespacese.html#a1daa21dcf920cc90f3cadba04672c648a1e0541b6957bd8cfa473609204c50741">NARY_EXPR</a>, 
<a class="el" href="namespacese.html#a1daa21dcf920cc90f3cadba04672c648aa862e7b14754591729e4821028588abe">EXT_EXPR</a> =  256u
<br/>
 }</td></tr>
<tr class="memdesc:a1daa21dcf920cc90f3cadba04672c648"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expr subclass identifier.  <a href="namespacese.html#a1daa21dcf920cc90f3cadba04672c648">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a68daa7bd761b22e17f8b5dcf1f1173a1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a68daa7bd761b22e17f8b5dcf1f1173a1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacese.html#a68daa7bd761b22e17f8b5dcf1f1173a1">get_commutative_attr</a> (const <a class="el" href="namespacese.html#ab51adead44287e1acb1ea83d31c52144">OperatorAttr</a> attr)</td></tr>
<tr class="memdesc:a68daa7bd761b22e17f8b5dcf1f1173a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the commutative bit on? <br/></td></tr>
<tr class="memitem:a82577075f1da697c33965f8f1ac53427"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a82577075f1da697c33965f8f1ac53427"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacese.html#a82577075f1da697c33965f8f1ac53427">get_associative_attr</a> (const <a class="el" href="namespacese.html#ab51adead44287e1acb1ea83d31c52144">OperatorAttr</a> attr)</td></tr>
<tr class="memdesc:a82577075f1da697c33965f8f1ac53427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the associative bit on? <br/></td></tr>
<tr class="memitem:ac85b73faa40a3f11bc4fc52117ae89b2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac85b73faa40a3f11bc4fc52117ae89b2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacese.html#ac85b73faa40a3f11bc4fc52117ae89b2">get_identity_attr</a> (const <a class="el" href="namespacese.html#ab51adead44287e1acb1ea83d31c52144">OperatorAttr</a> attr)</td></tr>
<tr class="memdesc:ac85b73faa40a3f11bc4fc52117ae89b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the identity element bit on? <br/></td></tr>
<tr class="memitem:ac2de5beacf5cb57659405ff66c43e5a6"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacese.html#a1daa21dcf920cc90f3cadba04672c648">ExprKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacese.html#ac2de5beacf5cb57659405ff66c43e5a6">ext_expr_kind</a> (unsigned short id)</td></tr>
<tr class="memdesc:ac2de5beacf5cb57659405ff66c43e5a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an ExprKind identifier for an external <a class="el" href="classse_1_1_expr.html" title="Base class for a symbolic expression such as &quot;y = x + 7&quot;.">Expr</a> subclass.  <a href="#ac2de5beacf5cb57659405ff66c43e5a6"></a><br/></td></tr>
<tr class="memitem:abe052ddc8b877e2b909f1a52d44c5502"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe052ddc8b877e2b909f1a52d44c5502"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;out, const <a class="el" href="namespacese.html#a594ed393deaf50eee0630623a84ab9bb">SharedExpr</a> &amp;expr)</td></tr>
<tr class="memitem:a60858c861e7e74961d121ce4fd5ef5bf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a60858c861e7e74961d121ce4fd5ef5bf"></a>
<a class="el" href="classse_1_1_tracer.html">Tracer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacese.html#a60858c861e7e74961d121ce4fd5ef5bf">tracer</a> ()</td></tr>
<tr class="memdesc:a60858c861e7e74961d121ce4fd5ef5bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static object which can record path constraints. <br/></td></tr>
<tr class="memitem:a78eaad60b7258f63ad85a61577f61d87"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a78eaad60b7258f63ad85a61577f61d87"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classse_1_1_value.html">Value</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacese.html#a78eaad60b7258f63ad85a61577f61d87">make_value</a> (const T value)</td></tr>
<tr class="memdesc:a78eaad60b7258f63ad85a61577f61d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create concrete value for multi-path and single-path symbolic execution.  <a href="#a78eaad60b7258f63ad85a61577f61d87"></a><br/></td></tr>
<tr class="memitem:a30ce74f589841461c6b57071ea4b36e4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a30ce74f589841461c6b57071ea4b36e4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classse_1_1_value.html">Value</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacese.html#a30ce74f589841461c6b57071ea4b36e4">any</a> (const std::string &amp;identifier)</td></tr>
<tr class="memdesc:a30ce74f589841461c6b57071ea4b36e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a symbolic value of type T.  <a href="#a30ce74f589841461c6b57071ea4b36e4"></a><br/></td></tr>
<tr class="memitem:a2bd601870ff77a9686158efba1c1f8ba"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2bd601870ff77a9686158efba1c1f8ba"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2bd601870ff77a9686158efba1c1f8ba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacese.html#a2bd601870ff77a9686158efba1c1f8ba">set_symbolic</a> (const T &amp;, const std::string &amp;identifier)</td></tr>
<tr class="memdesc:a2bd601870ff77a9686158efba1c1f8ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quiescence treatment of built-in types to increase interoperability. <br/></td></tr>
<tr class="memitem:adbf1b4949b4a9a31ea88538073b3900d"><td class="memTemplParams" colspan="2"><a class="anchor" id="adbf1b4949b4a9a31ea88538073b3900d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:adbf1b4949b4a9a31ea88538073b3900d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacese.html#adbf1b4949b4a9a31ea88538073b3900d">set_symbolic</a> (const T &amp;)</td></tr>
<tr class="memdesc:adbf1b4949b4a9a31ea88538073b3900d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quiescence treatment of built-in types to increase interoperability. <br/></td></tr>
<tr class="memitem:afad4b74a605393e1cde94f4ac7eb93c1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afad4b74a605393e1cde94f4ac7eb93c1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacese.html#afad4b74a605393e1cde94f4ac7eb93c1">set_symbolic</a> (<a class="el" href="classse_1_1_var.html">Var</a>&lt; T &gt; &amp;var, const std::string &amp;identifier)</td></tr>
<tr class="memdesc:afad4b74a605393e1cde94f4ac7eb93c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force the given variable to be symbolic.  <a href="#afad4b74a605393e1cde94f4ac7eb93c1"></a><br/></td></tr>
<tr class="memitem:a4190e22120930af402d2dc03311d9fee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacese.html#a4190e22120930af402d2dc03311d9fee">reset_var_seq</a> ()</td></tr>
<tr class="memdesc:a4190e22120930af402d2dc03311d9fee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set counter for auto generated variable identifiers to zero.  <a href="#a4190e22120930af402d2dc03311d9fee"></a><br/></td></tr>
<tr class="memitem:a1d23aa849d1423caa74a5650e680e576"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacese.html#a1d23aa849d1423caa74a5650e680e576">reset_tracer</a> ()</td></tr>
<tr class="memdesc:a1d23aa849d1423caa74a5650e680e576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear static path constraints.  <a href="#a1d23aa849d1423caa74a5650e680e576"></a><br/></td></tr>
<tr class="memitem:afbf3a5bceb1c1c6a691b340a047f3fea"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacese.html#afbf3a5bceb1c1c6a691b340a047f3fea">create_identifier</a> ()</td></tr>
<tr class="memdesc:afbf3a5bceb1c1c6a691b340a047f3fea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a unique symbolic variable identifier.  <a href="#afbf3a5bceb1c1c6a691b340a047f3fea"></a><br/></td></tr>
<tr class="memitem:a37cca4a017b4200b089ed236c14aabc4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a37cca4a017b4200b089ed236c14aabc4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacese.html#a37cca4a017b4200b089ed236c14aabc4">set_symbolic</a> (<a class="el" href="classse_1_1_var.html">Var</a>&lt; T &gt; &amp;var)</td></tr>
<tr class="memdesc:a37cca4a017b4200b089ed236c14aabc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force the given variable to be symbolic.  <a href="#a37cca4a017b4200b089ed236c14aabc4"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ae7c0528dc3483af2b5918da7adac4184"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacese.html#a9e4d2d07e23bdbb4cf63c4041f33639d">Operator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacese.html#ae7c0528dc3483af2b5918da7adac4184">UNARY_BEGIN</a></td></tr>
<tr class="memdesc:ae7c0528dc3483af2b5918da7adac4184"><td class="mdescLeft">&#160;</td><td class="mdescRight">First unary operator.  <a href="#ae7c0528dc3483af2b5918da7adac4184"></a><br/></td></tr>
<tr class="memitem:affdde9f8a38dbc86ac26530a9f2f42ef"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacese.html#a9e4d2d07e23bdbb4cf63c4041f33639d">Operator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacese.html#affdde9f8a38dbc86ac26530a9f2f42ef">UNARY_END</a></td></tr>
<tr class="memdesc:affdde9f8a38dbc86ac26530a9f2f42ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Last unary operator.  <a href="#affdde9f8a38dbc86ac26530a9f2f42ef"></a><br/></td></tr>
<tr class="memitem:a5f6e8f5e9f01a5ef3c0bf0dc6a43f8f8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacese.html#a9e4d2d07e23bdbb4cf63c4041f33639d">Operator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacese.html#a5f6e8f5e9f01a5ef3c0bf0dc6a43f8f8">NARY_BEGIN</a></td></tr>
<tr class="memdesc:a5f6e8f5e9f01a5ef3c0bf0dc6a43f8f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">First nary operator.  <a href="#a5f6e8f5e9f01a5ef3c0bf0dc6a43f8f8"></a><br/></td></tr>
<tr class="memitem:aa90d0e133c8a590ed2562045e6cbb983"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacese.html#a9e4d2d07e23bdbb4cf63c4041f33639d">Operator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacese.html#aa90d0e133c8a590ed2562045e6cbb983">NARY_END</a></td></tr>
<tr class="memdesc:aa90d0e133c8a590ed2562045e6cbb983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Last binary operator.  <a href="#aa90d0e133c8a590ed2562045e6cbb983"></a><br/></td></tr>
<tr class="memitem:affbbd1918df1e883dac205cdba1e63bf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="affbbd1918df1e883dac205cdba1e63bf"></a>
const <a class="el" href="namespacese.html#a39a431ff182bfd5e6480bb197ca64f3a">Version</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacese.html#affbbd1918df1e883dac205cdba1e63bf">VZERO</a> = 0LL</td></tr>
<tr class="memdesc:affbbd1918df1e883dac205cdba1e63bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero according to <a class="el" href="namespacese.html#a39a431ff182bfd5e6480bb197ca64f3a">Version</a> type. <br/></td></tr>
<tr class="memitem:a4e5330894da5a3dd097fa7634868cd29"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacese.html#a4e5330894da5a3dd097fa7634868cd29">var_seq</a></td></tr>
<tr class="memdesc:a4e5330894da5a3dd097fa7634868cd29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal non-decreasing counter.  <a href="#a4e5330894da5a3dd097fa7634868cd29"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Symbolic execution namespace. </p>
</div><hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ab51adead44287e1acb1ea83d31c52144"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned char <a class="el" href="namespacese.html#ab51adead44287e1acb1ea83d31c52144">se::OperatorAttr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bitmask to describe the mathematical properties of an operator. </p>
<p>A bitwise combination of enum <a class="el" href="namespacese.html#acdd644613b7c848c7f6e7e02e0f3029d">OperatorAttrBit</a> values.</p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="namespacese.html#a68daa7bd761b22e17f8b5dcf1f1173a1" title="Is the commutative bit on?">get_commutative_attr(const OperatorAttr)</a> </dd>
<dd>
<a class="el" href="namespacese.html#a68daa7bd761b22e17f8b5dcf1f1173a1" title="Is the commutative bit on?">get_commutative_attr(const OperatorAttr)</a> </dd>
<dd>
<a class="el" href="namespacese.html#ac85b73faa40a3f11bc4fc52117ae89b2" title="Is the identity element bit on?">get_identity_attr(const OperatorAttr)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a594ed393deaf50eee0630623a84ab9bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::shared_ptr&lt; <a class="el" href="classse_1_1_expr.html">Expr</a> &gt; <a class="el" href="namespacese.html#a594ed393deaf50eee0630623a84ab9bb">se::SharedExpr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vertex in the DAG which represents a symbolic expression. </p>
<p>Vertices are shared in order to minimize the size of the DAG. Since this sharing is implemented through C++11 smart pointers, their reference counters can be used when computing the minimal static single assignment form (SSA) of a DAG. This sharing necessitates that a SharedExpr is never modified once it has been inserted into the DAG. Thus, if an <a class="el" href="classse_1_1_expr.html" title="Base class for a symbolic expression such as &quot;y = x + 7&quot;.">Expr</a> subclass is mutable, a SharedExpr should only be constructed from a copy of the expression.</p>
<dl class="section warning"><dt>Warning:</dt><dd>When symbolic expression is shared, it should never be modified </dd></dl>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a1daa21dcf920cc90f3cadba04672c648"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacese.html#a1daa21dcf920cc90f3cadba04672c648">se::ExprKind</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classse_1_1_expr.html" title="Base class for a symbolic expression such as &quot;y = x + 7&quot;.">Expr</a> subclass identifier. </p>
<p><a class="el" href="classse_1_1_expr.html" title="Base class for a symbolic expression such as &quot;y = x + 7&quot;.">Expr</a> subclasses which are not part of the library must register with an enum value that is greater than or equal to <a class="el" href="namespacese.html#a1daa21dcf920cc90f3cadba04672c648aa862e7b14754591729e4821028588abe">EXT_EXPR</a>. This can be facilitated by <a class="el" href="namespacese.html#ac2de5beacf5cb57659405ff66c43e5a6" title="Create an ExprKind identifier for an external Expr subclass.">ext_expr_kind(unsigned short)</a>. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a1daa21dcf920cc90f3cadba04672c648ad9ebe1f0705856801b82ac4204db6598"></a>ANY_EXPR</em>&nbsp;</td><td>
<p>Identifier for <a class="el" href="classse_1_1_any_expr.html" title="Type-safe symbolic variable of an arbitrary value.">AnyExpr</a>. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a1daa21dcf920cc90f3cadba04672c648a99877150257de5aa9b8a8befe788686f"></a>VALUE_EXPR</em>&nbsp;</td><td>
<p>Identifier for <a class="el" href="classse_1_1_value_expr.html" title="Type-safe concrete value with an optional symbolic value.">ValueExpr</a>. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a1daa21dcf920cc90f3cadba04672c648aacc93b779a93ab83b9613dee45748afd"></a>CAST_EXPR</em>&nbsp;</td><td>
<p>Identifier for <a class="el" href="classse_1_1_cast_expr.html" title="Type cast of another symbolic expression.">CastExpr</a>. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a1daa21dcf920cc90f3cadba04672c648ae7f0e9d072750a6b360935ad72cc133b"></a>UNARY_EXPR</em>&nbsp;</td><td>
<p>Identifier for <a class="el" href="classse_1_1_unary_expr.html" title="Operator with one operand.">UnaryExpr</a>. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a1daa21dcf920cc90f3cadba04672c648a7924143d3b519e5a3f36027337c5a2a6"></a>ITE_EXPR</em>&nbsp;</td><td>
<p>Identifier for <a class="el" href="classse_1_1_if_then_else_expr.html" title="Ternary expression of the form &quot;x ? y : z&quot;.">IfThenElseExpr</a>. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a1daa21dcf920cc90f3cadba04672c648a1e0541b6957bd8cfa473609204c50741"></a>NARY_EXPR</em>&nbsp;</td><td>
<p>Identifier for <a class="el" href="classse_1_1_nary_expr.html" title="Operator with several operands.">NaryExpr</a>. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a1daa21dcf920cc90f3cadba04672c648aa862e7b14754591729e4821028588abe"></a>EXT_EXPR</em>&nbsp;</td><td>
<p><a class="el" href="classse_1_1_expr.html" title="Base class for a symbolic expression such as &quot;y = x + 7&quot;.">Expr</a> subclasses which are not part of the library must use this value.</p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="namespacese.html#ac2de5beacf5cb57659405ff66c43e5a6" title="Create an ExprKind identifier for an external Expr subclass.">ext_expr_kind(unsigned short)</a> </dd></dl>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a9e4d2d07e23bdbb4cf63c4041f33639d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacese.html#a9e4d2d07e23bdbb4cf63c4041f33639d">se::Operator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Built-in C++ operators for which symbolic execution is supported. </p>
<p>Operators are ordered according to their arity. This ordering can be used to create fast runtime lookup tables. To facilitate this, there are extern constants that mark the first and last n-arity operator in this enum type. Since some nary operators are also unary (e.g. <a class="el" href="namespacese.html#a9e4d2d07e23bdbb4cf63c4041f33639dac7cb225b609ddda8c036588cd89012a5">ADD</a>), these delimiter values can overlap. The last unary operator marks the beginning of operators that never accept less than two operands (e.g. <a class="el" href="namespacese.html#a9e4d2d07e23bdbb4cf63c4041f33639da3b1ad3a90356bfe8ea6fdea8de4f89ce">LSS</a>). The following schematic diagram illustrates this: </p>
<pre class="fragment">+ - - - - - - - - - - - - - - - - - - - + &lt;- 0 (unsigned short)
|                Future Use             |
+ - - - - - - - - - - - - - - - - - - - + &lt;- UNARY_BEGIN
|                                       |
|        Unary Operators (e.g. ADD)     |
|                                       |
+ - - - - - - - - - - - - - - - - - - - + &lt;- NARY_BEGIN
|                                       |
|    Unary &amp; Nary Operators (e.g. ADD)  |
|                                       |
+ - - - - - - - - - - - - - - - - - - - + &lt;- UNARY_END
|                                       |  
|         Binary &amp; Nary Operators       |
|            (e.g. LSS, ADD)            |
|                                       |
+ - - - - - - - - - - - - - - - - - - - + &lt;- NARY_END
|                  ...                  |
</pre><p>Note that all operators whose enum value is greater than <a class="el" href="namespacese.html#a5f6e8f5e9f01a5ef3c0bf0dc6a43f8f8">NARY_BEGIN</a> and less than <a class="el" href="namespacese.html#affdde9f8a38dbc86ac26530a9f2f42ef">UNARY_END</a> should be associative unless otherwise specified through the <a class="el" href="namespacese.html#ab51adead44287e1acb1ea83d31c52144">operator's attributes</a>. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a9e4d2d07e23bdbb4cf63c4041f33639dafacbb2ef8d89bfcdbca19d4a3d8e9188"></a>NOT</em>&nbsp;</td><td>
<pre class="fragment">!</pre> </td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9e4d2d07e23bdbb4cf63c4041f33639dac7cb225b609ddda8c036588cd89012a5"></a>ADD</em>&nbsp;</td><td>
<pre class="fragment">+</pre> </td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9e4d2d07e23bdbb4cf63c4041f33639da8e844aa5bea1f00ebd5037ed57d805c8"></a>LAND</em>&nbsp;</td><td>
<pre class="fragment">&amp;&amp;</pre> </td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9e4d2d07e23bdbb4cf63c4041f33639dac0ad30ee11ab87674acec45b3fc0b87d"></a>LOR</em>&nbsp;</td><td>
<pre class="fragment">||</pre> </td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9e4d2d07e23bdbb4cf63c4041f33639daeae77bf86710908e2d9fcd3a3714bed9"></a>EQL</em>&nbsp;</td><td>
<pre class="fragment">=</pre> </td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9e4d2d07e23bdbb4cf63c4041f33639da3b1ad3a90356bfe8ea6fdea8de4f89ce"></a>LSS</em>&nbsp;</td><td>
<pre class="fragment">&lt;</pre> </td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="acdd644613b7c848c7f6e7e02e0f3029d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacese.html#acdd644613b7c848c7f6e7e02e0f3029d">se::OperatorAttrBit</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit vector to define and inspect an operator's mathematical properties. </p>
<p>Use bitwise operators judiciously to combine mathematical properties into a bitmask of type <a class="el" href="namespacese.html#ab51adead44287e1acb1ea83d31c52144">OperatorAttr</a>. Unusual value combinations should be avoided. For example, it is uncommon for an operator to be non-associative but commutative (such an operator is also known as a magma).</p>
<dl class="section remark"><dt>Remarks:</dt><dd>if both <a class="el" href="namespacese.html#acdd644613b7c848c7f6e7e02e0f3029daead562a73585b2121d0e24a8a801576d">LASSOC_ATTR</a> and <a class="el" href="namespacese.html#acdd644613b7c848c7f6e7e02e0f3029da83b0d160857aff077e9513160169ccc0">RASSOC_ATTR</a> are set, then the operator must be associative, i.e. ((x ~ y) ~ z) = (x ~ (y ~ z)) </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="acdd644613b7c848c7f6e7e02e0f3029da3db99f785499929d65ef9d713bcbc4c0"></a>CLEAR_ATTR</em>&nbsp;</td><td>
<p>Clear all other attributes via bitwise AND. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="acdd644613b7c848c7f6e7e02e0f3029daead562a73585b2121d0e24a8a801576d"></a>LASSOC_ATTR</em>&nbsp;</td><td>
<p>Operator is left associative, i.e. x ~ y ~ z = (x ~ y) ~ z. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="acdd644613b7c848c7f6e7e02e0f3029da83b0d160857aff077e9513160169ccc0"></a>RASSOC_ATTR</em>&nbsp;</td><td>
<p>Operator is right associative, i.e. x ~ y ~ z = x ~ (y ~ z) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="acdd644613b7c848c7f6e7e02e0f3029da7c6831cfc8632d333b20faa1aa8a2058"></a>COMM_ATTR</em>&nbsp;</td><td>
<p>Operator is commutative, i.e. (x ~ y) = (y ~ x) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="acdd644613b7c848c7f6e7e02e0f3029dae0fbde84870b0821f683bd4ff6ca4593"></a>HAS_ID_ELEMENT_ATTR</em>&nbsp;</td><td>
<p>Operator has a unique identity element e, i.e. x ~ e = e ~ x = x. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a7970802251b211c565f656366346d60f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacese.html#a7970802251b211c565f656366346d60f">se::Type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Built-in primitive types for which symbolic execution is supported. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a7970802251b211c565f656366346d60fa87c78d3abab9c703d025dd7d12952b31"></a>BOOL</em>&nbsp;</td><td>
<dl class="section see"><dt>See also:</dt><dd>std::numeric_limits&lt;bool&gt; </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a7970802251b211c565f656366346d60faf79133a9a225e1df662c7bc4ed1c6b8b"></a>CHAR</em>&nbsp;</td><td>
<dl class="section see"><dt>See also:</dt><dd>std::numeric_limits&lt;char&gt; </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a7970802251b211c565f656366346d60fa318b179bc8e33e9d34b00280873c3b4d"></a>INT</em>&nbsp;</td><td>
<dl class="section see"><dt>See also:</dt><dd>std::numeric_limits&lt;int&gt; </dd></dl>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a30ce74f589841461c6b57071ea4b36e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classse_1_1_value.html">Value</a>&lt;T&gt; se::any </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a symbolic value of type T. </p>
<p>Create an arbitrary value which is only suitable for multi-path (i.e. CBMC-style) symbolic execution. The supplied string corresponds to the name of the newly created <a class="el" href="classse_1_1_any_expr.html">symbolic variable</a>. </p>

</div>
</div>
<a class="anchor" id="afbf3a5bceb1c1c6a691b340a047f3fea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string se::create_identifier </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a unique symbolic variable identifier. </p>
<p>The identifier has the form "Var_N" where N is an non-negative integer which increments with each call. </p>

</div>
</div>
<a class="anchor" id="ac2de5beacf5cb57659405ff66c43e5a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacese.html#a1daa21dcf920cc90f3cadba04672c648">ExprKind</a> se::ext_expr_kind </td>
          <td>(</td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an ExprKind identifier for an external <a class="el" href="classse_1_1_expr.html" title="Base class for a symbolic expression such as &quot;y = x + 7&quot;.">Expr</a> subclass. </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="namespacese.html#a1daa21dcf920cc90f3cadba04672c648aa862e7b14754591729e4821028588abe">EXT_EXPR</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a78eaad60b7258f63ad85a61577f61d87"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classse_1_1_value.html">Value</a>&lt;T&gt; se::make_value </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create concrete value for multi-path and single-path symbolic execution. </p>
<p>Create a new value suitable for multi-path (i.e. CBMC-style) and single-path (i.e. DART-style) symbolic execution. The latter is also known as concolic execution.</p>
<dl class="section remark"><dt>Remarks:</dt><dd>Type T should be a primitive type. </dd></dl>

</div>
</div>
<a class="anchor" id="a1d23aa849d1423caa74a5650e680e576"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void se::reset_tracer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear static path constraints. </p>
<p>Clear the path constraints of the <a class="el" href="namespacese.html#a60858c861e7e74961d121ce4fd5ef5bf">global</a> tracer.</p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="tracer_8h.html">tracer.h</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4190e22120930af402d2dc03311d9fee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void se::reset_var_seq </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set counter for auto generated variable identifiers to zero. </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="namespacese.html#a4e5330894da5a3dd097fa7634868cd29" title="Internal non-decreasing counter.">var_seq</a> </dd>
<dd>
<a class="el" href="namespacese.html#afbf3a5bceb1c1c6a691b340a047f3fea" title="Create a unique symbolic variable identifier.">create_identifier()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afad4b74a605393e1cde94f4ac7eb93c1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void se::set_symbolic </td>
          <td>(</td>
          <td class="paramtype">Var&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Force the given variable to be symbolic. </p>
<p>The name should be unique among the symbolic inputs to the program under test. Changes of the string do not effect the symbolic variable name. </p>

</div>
</div>
<a class="anchor" id="a37cca4a017b4200b089ed236c14aabc4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void se::set_symbolic </td>
          <td>(</td>
          <td class="paramtype">Var&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Force the given variable to be symbolic. </p>
<p>Symbolic variable identifier is <a class="el" href="namespacese.html#afbf3a5bceb1c1c6a691b340a047f3fea">auto generated</a>. </p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a5f6e8f5e9f01a5ef3c0bf0dc6a43f8f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacese.html#a9e4d2d07e23bdbb4cf63c4041f33639d">Operator</a> se::NARY_BEGIN</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>First nary operator. </p>
<p><a class="el" href="namespacese.html#a5f6e8f5e9f01a5ef3c0bf0dc6a43f8f8">NARY_BEGIN</a> is always less than or equal to <a class="el" href="namespacese.html#aa90d0e133c8a590ed2562045e6cbb983">NARY_END</a>. </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="namespacese.html#a9e4d2d07e23bdbb4cf63c4041f33639d" title="Built-in C++ operators for which symbolic execution is supported.">Operator</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa90d0e133c8a590ed2562045e6cbb983"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacese.html#a9e4d2d07e23bdbb4cf63c4041f33639d">Operator</a> se::NARY_END</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Last binary operator. </p>
<p>The range <a class="el" href="namespacese.html#affdde9f8a38dbc86ac26530a9f2f42ef">UNARY_END</a> ... <a class="el" href="namespacese.html#aa90d0e133c8a590ed2562045e6cbb983">NARY_END</a> gives all the operators which require at least two operands. </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="namespacese.html#a9e4d2d07e23bdbb4cf63c4041f33639d" title="Built-in C++ operators for which symbolic execution is supported.">Operator</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae7c0528dc3483af2b5918da7adac4184"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacese.html#a9e4d2d07e23bdbb4cf63c4041f33639d">Operator</a> se::UNARY_BEGIN</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>First unary operator. </p>
<p><a class="el" href="namespacese.html#ae7c0528dc3483af2b5918da7adac4184">UNARY_BEGIN</a> is always less than or equal to <a class="el" href="namespacese.html#affdde9f8a38dbc86ac26530a9f2f42ef">UNARY_END</a>. </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="namespacese.html#a9e4d2d07e23bdbb4cf63c4041f33639d" title="Built-in C++ operators for which symbolic execution is supported.">Operator</a> </dd></dl>

</div>
</div>
<a class="anchor" id="affdde9f8a38dbc86ac26530a9f2f42ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacese.html#a9e4d2d07e23bdbb4cf63c4041f33639d">Operator</a> se::UNARY_END</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Last unary operator. </p>
<p><a class="el" href="namespacese.html#affdde9f8a38dbc86ac26530a9f2f42ef">UNARY_END</a> is always less than or equal <a class="el" href="namespacese.html#aa90d0e133c8a590ed2562045e6cbb983">NARY_END</a>. </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="namespacese.html#a9e4d2d07e23bdbb4cf63c4041f33639d" title="Built-in C++ operators for which symbolic execution is supported.">Operator</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4e5330894da5a3dd097fa7634868cd29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int se::var_seq</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal non-decreasing counter. </p>
<p>Count up with each <a class="el" href="namespacese.html#adbf1b4949b4a9a31ea88538073b3900d" title="Quiescence treatment of built-in types to increase interoperability.">set_symbolic(const T&amp;)</a> call. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Sep 16 2012 17:15:28 for libse by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.1
</small></address>
</body>
</html>
