<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>libse: se::Var&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libse
   &#160;<span id="projectnumber">0.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacese.html">se</a></li><li class="navelem"><a class="el" href="classse_1_1_var.html">Var</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">se::Var&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Type-safe (symbolic/concrete) rvalue.  
 <a href="classse_1_1_var.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="var_8h_source.html">var.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for se::Var&lt; T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classse_1_1_var.png" usemap="#se::Var&lt; T &gt;_map" alt=""/>
  <map id="se::Var&lt; T &gt;_map" name="se::Var&lt; T &gt;_map">
<area href="classse_1_1_abstract_var.html" title="Base class for a (symbolic/concrete) lvalue." alt="se::AbstractVar" shape="rect" coords="0,0,99,24"/>
</map>
 </div></div>

<p><a href="classse_1_1_var-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>State</b></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aed84f4d13530ca4a6573a8576b0566a2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed84f4d13530ca4a6573a8576b0566a2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_var.html#aed84f4d13530ca4a6573a8576b0566a2">Var</a> (const T concrete_data)</td></tr>
<tr class="memdesc:aed84f4d13530ca4a6573a8576b0566a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete variable. <br/></td></tr>
<tr class="memitem:a2ea8fe4b09c7a2fa69042d3d3ab469f1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ea8fe4b09c7a2fa69042d3d3ab469f1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_var.html#a2ea8fe4b09c7a2fa69042d3d3ab469f1">Var</a> (const <a class="el" href="classse_1_1_value.html">Value</a>&lt; T &gt; &amp;<a class="el" href="classse_1_1_var.html#a73b0dc037906ce363dbf81a07ec86c19">value</a>)</td></tr>
<tr class="memdesc:a2ea8fe4b09c7a2fa69042d3d3ab469f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable based on another (symbolic/concrete) value of the same type. <br/></td></tr>
<tr class="memitem:a61a56e25d065030f8090a29ca382148f"><td class="memTemplParams" colspan="2">template&lt;typename S &gt; </td></tr>
<tr class="memitem:a61a56e25d065030f8090a29ca382148f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classse_1_1_var.html#a61a56e25d065030f8090a29ca382148f">Var</a> (const <a class="el" href="classse_1_1_value.html">Value</a>&lt; S &gt; &amp;<a class="el" href="classse_1_1_var.html#a73b0dc037906ce363dbf81a07ec86c19">value</a>)</td></tr>
<tr class="memdesc:a61a56e25d065030f8090a29ca382148f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable based on another (symbolic/concrete) value of a different type.  <a href="#a61a56e25d065030f8090a29ca382148f"></a><br/></td></tr>
<tr class="memitem:a646ea7090b4c56a1998b695ee01c367e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_var.html#a646ea7090b4c56a1998b695ee01c367e">Var</a> (const <a class="el" href="classse_1_1_var.html">Var</a> &amp;other)</td></tr>
<tr class="memdesc:a646ea7090b4c56a1998b695ee01c367e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe copy constructor.  <a href="#a646ea7090b4c56a1998b695ee01c367e"></a><br/></td></tr>
<tr class="memitem:af28ada367980de0f6601ef9f3a009e8d"><td class="memTemplParams" colspan="2">template&lt;typename S &gt; </td></tr>
<tr class="memitem:af28ada367980de0f6601ef9f3a009e8d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classse_1_1_var.html#af28ada367980de0f6601ef9f3a009e8d">Var</a> (const <a class="el" href="classse_1_1_var.html">Var</a>&lt; S &gt; &amp;other)</td></tr>
<tr class="memdesc:af28ada367980de0f6601ef9f3a009e8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsafe copy constructor with type casting.  <a href="#af28ada367980de0f6601ef9f3a009e8d"></a><br/></td></tr>
<tr class="memitem:a73b0dc037906ce363dbf81a07ec86c19"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classse_1_1_value.html">Value</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_var.html#a73b0dc037906ce363dbf81a07ec86c19">value</a> () const </td></tr>
<tr class="memdesc:a73b0dc037906ce363dbf81a07ec86c19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete/symbolic value.  <a href="#a73b0dc037906ce363dbf81a07ec86c19"></a><br/></td></tr>
<tr class="memitem:a8c69429c7418bfaa43d2832c1b817b3b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_var.html#a8c69429c7418bfaa43d2832c1b817b3b">operator T</a> () const </td></tr>
<tr class="memdesc:a8c69429c7418bfaa43d2832c1b817b3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete data (if defined)  <a href="#a8c69429c7418bfaa43d2832c1b817b3b"></a><br/></td></tr>
<tr class="memitem:a140f6dbdb0d56fc26eaddb85a488e295"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classse_1_1_var.html">Var</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_var.html#a140f6dbdb0d56fc26eaddb85a488e295">operator=</a> (const <a class="el" href="classse_1_1_var.html">Var</a> &amp;other)</td></tr>
<tr class="memdesc:a140f6dbdb0d56fc26eaddb85a488e295"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the value and propagate cast information.  <a href="#a140f6dbdb0d56fc26eaddb85a488e295"></a><br/></td></tr>
<tr class="memitem:af04cbe42946832a5af846d4b8a292322"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacese.html#a7970802251b211c565f656366346d60f">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_var.html#af04cbe42946832a5af846d4b8a292322">type</a> () const </td></tr>
<tr class="memdesc:af04cbe42946832a5af846d4b8a292322"><td class="mdescLeft">&#160;</td><td class="mdescRight">type information  <a href="#af04cbe42946832a5af846d4b8a292322"></a><br/></td></tr>
<tr class="memitem:a775bb1830c000d3949f3059af0dff9e0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_var.html#a775bb1830c000d3949f3059af0dff9e0">is_cast</a> () const </td></tr>
<tr class="memdesc:a775bb1830c000d3949f3059af0dff9e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is concrete or symbolic value subject to an up or down cast?  <a href="#a775bb1830c000d3949f3059af0dff9e0"></a><br/></td></tr>
<tr class="memitem:a15e2a0dfcc0eb02ffad43513772d2697"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_var.html#a15e2a0dfcc0eb02ffad43513772d2697">set_symbolic</a> (const std::string &amp;identifier)</td></tr>
<tr class="memdesc:a15e2a0dfcc0eb02ffad43513772d2697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force variable to be symbolic.  <a href="#a15e2a0dfcc0eb02ffad43513772d2697"></a><br/></td></tr>
<tr class="memitem:ac9961bf685e99775271001f063d30e74"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_var.html#ac9961bf685e99775271001f063d30e74">is_symbolic</a> () const </td></tr>
<tr class="memdesc:ac9961bf685e99775271001f063d30e74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is symbolic expression defined?  <a href="#ac9961bf685e99775271001f063d30e74"></a><br/></td></tr>
<tr class="memitem:a87dc71b44618873a3cfe9c4053ae1cc2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_var.html#a87dc71b44618873a3cfe9c4053ae1cc2">is_concrete</a> () const </td></tr>
<tr class="memdesc:a87dc71b44618873a3cfe9c4053ae1cc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is concrete data defined?  <a href="#a87dc71b44618873a3cfe9c4053ae1cc2"></a><br/></td></tr>
<tr class="memitem:aa577b2f7974dbdf6b302783b21a0dbd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacese.html#a39a431ff182bfd5e6480bb197ca64f3a">Version</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_var.html#aa577b2f7974dbdf6b302783b21a0dbd5">version</a> () const </td></tr>
<tr class="memdesc:aa577b2f7974dbdf6b302783b21a0dbd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-decreasing number which increments with every assignment.  <a href="#aa577b2f7974dbdf6b302783b21a0dbd5"></a><br/></td></tr>
<tr class="memitem:a05015d6ee9dfde7711e19aedb7ae7c2b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacese.html#a594ed393deaf50eee0630623a84ab9bb">SharedExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_var.html#a05015d6ee9dfde7711e19aedb7ae7c2b">expr</a> () const </td></tr>
<tr class="memdesc:a05015d6ee9dfde7711e19aedb7ae7c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression of the variable.  <a href="#a05015d6ee9dfde7711e19aedb7ae7c2b"></a><br/></td></tr>
<tr class="memitem:a91fde7edd704200b1f288a8b6eb38748"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_var.html#a91fde7edd704200b1f288a8b6eb38748">set_expr</a> (const <a class="el" href="namespacese.html#a594ed393deaf50eee0630623a84ab9bb">SharedExpr</a> &amp;<a class="el" href="classse_1_1_var.html#a05015d6ee9dfde7711e19aedb7ae7c2b">expr</a>)</td></tr>
<tr class="memdesc:a91fde7edd704200b1f288a8b6eb38748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the symbolic expression of the variable.  <a href="#a91fde7edd704200b1f288a8b6eb38748"></a><br/></td></tr>
<tr class="memitem:a730795296d4eb08e9929f46f0705f086"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_var.html#a730795296d4eb08e9929f46f0705f086">stash</a> ()</td></tr>
<tr class="memdesc:a730795296d4eb08e9929f46f0705f086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save internal state.  <a href="#a730795296d4eb08e9929f46f0705f086"></a><br/></td></tr>
<tr class="memitem:acef96fa94c498b655f99eb36f156218e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_var.html#acef96fa94c498b655f99eb36f156218e">unstash</a> (bool restore)</td></tr>
<tr class="memdesc:acef96fa94c498b655f99eb36f156218e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore internal state (i.e. reverse <a class="el" href="classse_1_1_var.html#a730795296d4eb08e9929f46f0705f086" title="Save internal state.">stash()</a>)  <a href="#acef96fa94c498b655f99eb36f156218e"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br/>
class se::Var&lt; T &gt;</h3>

<p>Type-safe (symbolic/concrete) rvalue. </p>
<p>Example: </p>
<pre class="fragment">Int x = any&lt;int&gt;("X");
Int y = 7;
Int z = x + 3;
y = z + 5;
</pre><p>Here <code>x</code> is said to be a <a class="el" href="classse_1_1_var.html#ac9961bf685e99775271001f063d30e74">symbolic</a> variable whose <a class="el" href="classse_1_1_var.html#af04cbe42946832a5af846d4b8a292322" title="type information">type()</a> is <a class="el" href="namespacese.html#a7970802251b211c565f656366346d60fa318b179bc8e33e9d34b00280873c3b4d">INT</a>. In contrast, <code>y</code> is an integer variable with only concrete data (e.g. 7). However, <code>y</code> can become symbolic later in the symbolic execution of the program under test (e.g. last assignment). Due to <a class="el" href="classse_1_1_value.html#a57fa6bc1ed2ed40272daf6afbf0608f3">constant propagation</a>, <code>y</code>'s final <a class="el" href="classse_1_1_var.html#a05015d6ee9dfde7711e19aedb7ae7c2b" title="Symbolic expression of the variable.">Var&lt;T&gt;::expr()</a> is of the form "x + 8".</p>
<p>The concrete data and/or symbolic expression of a variable can be accessed through <a class="el" href="classse_1_1_var.html#a73b0dc037906ce363dbf81a07ec86c19" title="Concrete/symbolic value.">value()</a>. See the <a class="el" href="classse_1_1_abstract_var.html" title="Base class for a (symbolic/concrete) lvalue.">AbstractVar</a> and <a class="el" href="classse_1_1_value.html" title="Type-safe (symbolic/concrete) lvalue.">Value</a> class documentation for more details.</p>
<p>The following table summarizes common mechanisms to create a variable:</p>
<table class="doxtable">
<tr>
<th>Code </th><th>Description</th></tr>
<tr>
<td>Var&lt;T&gt; x = <a class="el" href="namespacese.html#a30ce74f589841461c6b57071ea4b36e4">any</a>&lt;T&gt;("X") </td><td><a class="el" href="classse_1_1_var.html#ac9961bf685e99775271001f063d30e74">symbolic</a> variable of type <code>T</code> and identifier "X" </td></tr>
<tr>
<td>Var&lt;T&gt; x = [primitive value] </td><td><a class="el" href="classse_1_1_var.html#a87dc71b44618873a3cfe9c4053ae1cc2">concrete</a> variable of type <code>T</code> </td></tr>
<tr>
<td>Var&lt;T&gt; x = [primitive value]; x.<a class="el" href="classse_1_1_var.html#a15e2a0dfcc0eb02ffad43513772d2697">set_symbolic</a>("X") </td><td>variable of type <code>T</code> which is <a class="el" href="classse_1_1_var.html#ac9961bf685e99775271001f063d30e74">symbolic</a> and <a class="el" href="classse_1_1_var.html#a87dc71b44618873a3cfe9c4053ae1cc2">concrete</a> </td></tr>
</table>
<p>Once a variable has been created, it can be used as any other regular program variable as long as the required operators have been overloaded. </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a61a56e25d065030f8090a29ca382148f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classse_1_1_var.html">se::Var</a>&lt; T &gt;::<a class="el" href="classse_1_1_var.html">Var</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classse_1_1_value.html">Value</a>&lt; S &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Variable based on another (symbolic/concrete) value of a different type. </p>
<p>Since the type of the value differ from the template type T, the new variable's concrete data could be subject to precision loss; this is conservatively approximated by <a class="el" href="classse_1_1_var.html#a775bb1830c000d3949f3059af0dff9e0" title="Is concrete or symbolic value subject to an up or down cast?">is_cast()</a>. Moreover, if the value <a class="el" href="classse_1_1_var.html#ac9961bf685e99775271001f063d30e74" title="Is symbolic expression defined?">is_symbolic()</a>, the symbolic expression of the variable is going to have a new <a class="el" href="classse_1_1_cast_expr.html" title="Type cast of another symbolic expression.">CastExpr</a>. </p>

</div>
</div>
<a class="anchor" id="a646ea7090b4c56a1998b695ee01c367e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classse_1_1_var.html">se::Var</a>&lt; T &gt;::<a class="el" href="classse_1_1_var.html">Var</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classse_1_1_var.html">Var</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Safe copy constructor. </p>
<p>Copy constructor that instantiates a variable by creating a deep copy of the supplied variable's concrete data. Any symbolic expressions are shared between both the original and copied variable object until either one is modified. Note that casts are transitive: if other.is_cast() is true, then the copy's <a class="el" href="classse_1_1_var.html#a775bb1830c000d3949f3059af0dff9e0" title="Is concrete or symbolic value subject to an up or down cast?">is_cast()</a> is true. </p>

</div>
</div>
<a class="anchor" id="af28ada367980de0f6601ef9f3a009e8d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classse_1_1_var.html">se::Var</a>&lt; T &gt;::<a class="el" href="classse_1_1_var.html">Var</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classse_1_1_var.html">Var</a>&lt; S &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsafe copy constructor with type casting. </p>
<p>Copy conversion constructor that creates a copy of another variable. Incompatibilities between the type of the supplied variable's concrete data and the type of the instantiated variable object are resolved by implicit type casting. In the case in which the other variable is also symbolic, the new variable's <a class="el" href="classse_1_1_var.html#a05015d6ee9dfde7711e19aedb7ae7c2b" title="Symbolic expression of the variable.">expr()</a> is going to have a new <a class="el" href="classse_1_1_cast_expr.html" title="Type cast of another symbolic expression.">CastExpr</a>. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a05015d6ee9dfde7711e19aedb7ae7c2b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacese.html#a594ed393deaf50eee0630623a84ab9bb">SharedExpr</a> <a class="el" href="classse_1_1_var.html">se::Var</a>&lt; T &gt;::expr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Symbolic expression of the variable. </p>
<p>The return value is a NULL pointer if and only if <a class="el" href="classse_1_1_var.html#ac9961bf685e99775271001f063d30e74" title="Is symbolic expression defined?">is_symbolic()</a> is false. /see <a class="el" href="classse_1_1_abstract_value.html#a6cc055fb16a0b65cf889532c2b6b7629" title="Unsimplified symbolic expression.">AbstractValue::expr()</a> </p>

<p>Implements <a class="el" href="classse_1_1_abstract_var.html#aa6f6434d482f319bcf93b223d8373708">se::AbstractVar</a>.</p>

</div>
</div>
<a class="anchor" id="a775bb1830c000d3949f3059af0dff9e0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classse_1_1_var.html">se::Var</a>&lt; T &gt;::is_cast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is concrete or symbolic value subject to an up or down cast? </p>
<p><a class="el" href="classse_1_1_if.html" title="Control-flow annotation for multi-path symbolic execution of an if-then-else statement.">If</a> an unsafe type conversion is needed, then <a class="el" href="classse_1_1_var.html#a775bb1830c000d3949f3059af0dff9e0" title="Is concrete or symbolic value subject to an up or down cast?">is_cast()</a> returns true. Note that the converse is false since <a class="el" href="classse_1_1_var.html#a775bb1830c000d3949f3059af0dff9e0" title="Is concrete or symbolic value subject to an up or down cast?">is_cast()</a> also returns true for up casts. </p>

<p>Implements <a class="el" href="classse_1_1_abstract_var.html#a00fc2e78cbb1c1e8e118fe7000c8fa07">se::AbstractVar</a>.</p>

</div>
</div>
<a class="anchor" id="a87dc71b44618873a3cfe9c4053ae1cc2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classse_1_1_var.html">se::Var</a>&lt; T &gt;::is_concrete </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is concrete data defined? </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classse_1_1_abstract_value.html#ae7b88cb20bf1b639c14f25d5cc10de4e" title="Is concrete data defined?">AbstractValue::is_concrete()</a> </dd></dl>

<p>Implements <a class="el" href="classse_1_1_abstract_var.html#a45e5dfdeac76bb372bcf81d45c8f0037">se::AbstractVar</a>.</p>

</div>
</div>
<a class="anchor" id="ac9961bf685e99775271001f063d30e74"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classse_1_1_var.html">se::Var</a>&lt; T &gt;::is_symbolic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is symbolic expression defined? </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classse_1_1_abstract_value.html#a285c2bc007864c01d82191234b6a0c26" title="Is symbolic expression defined?">AbstractValue::is_symbolic()</a> </dd>
<dd>
<a class="el" href="classse_1_1_abstract_value.html#a6cc055fb16a0b65cf889532c2b6b7629" title="Unsimplified symbolic expression.">AbstractValue::expr()</a> </dd></dl>

<p>Implements <a class="el" href="classse_1_1_abstract_var.html#ada33e409d05ecb7670d67b517b9c53a9">se::AbstractVar</a>.</p>

</div>
</div>
<a class="anchor" id="a8c69429c7418bfaa43d2832c1b817b3b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classse_1_1_var.html">se::Var</a>&lt; T &gt;::operator T </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concrete data (if defined) </p>
<p>The return value is defined if and only if <a class="el" href="classse_1_1_var.html#a87dc71b44618873a3cfe9c4053ae1cc2" title="Is concrete data defined?">is_concrete()</a> is true. Note that if <a class="el" href="classse_1_1_var.html#ac9961bf685e99775271001f063d30e74" title="Is symbolic expression defined?">is_symbolic()</a> is true, the conversion could render concolic execution incomplete. Also note that the bool() conversion operator adds the symbolic expression to the <a class="el" href="namespacese.html#a60858c861e7e74961d121ce4fd5ef5bf">global</a> path constraints if and only if <a class="el" href="classse_1_1_var.html#ac9961bf685e99775271001f063d30e74" title="Is symbolic expression defined?">is_symbolic()</a> returns true.</p>
<p><a class="el" href="classse_1_1_if.html" title="Control-flow annotation for multi-path symbolic execution of an if-then-else statement.">If</a> type casts coerce the data, <a class="el" href="classse_1_1_var.html#a775bb1830c000d3949f3059af0dff9e0" title="Is concrete or symbolic value subject to an up or down cast?">is_cast()</a> returns true.</p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classse_1_1_value.html#a6890d434413966b00e0c5b21bc236edf" title="Concrete data (if defined)">Value::operator T()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a140f6dbdb0d56fc26eaddb85a488e295"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classse_1_1_var.html">Var</a>&amp; <a class="el" href="classse_1_1_var.html">se::Var</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classse_1_1_var.html">Var</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace the value and propagate cast information. </p>
<p>Copy any concrete data symbolic expression of the other variable. Any required type conversions are first performed by <a class="el" href="classse_1_1_var.html#af28ada367980de0f6601ef9f3a009e8d" title="Unsafe copy constructor with type casting.">Var(const Var&lt;S&gt;&amp;)</a>. Such a conversion could result in precision lost. This is conservatively approximated by <a class="el" href="classse_1_1_var.html#a775bb1830c000d3949f3059af0dff9e0" title="Is concrete or symbolic value subject to an up or down cast?">is_cast()</a>.</p>
<p>Note that when the variable is assigned to itself, no data is copied. Also self-assignment due to cause the version number to be incremented. </p>

</div>
</div>
<a class="anchor" id="a91fde7edd704200b1f288a8b6eb38748"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classse_1_1_var.html">se::Var</a>&lt; T &gt;::set_expr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacese.html#a594ed393deaf50eee0630623a84ab9bb">SharedExpr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the symbolic expression of the variable. </p>
<p>Unless the argument is NULL, <a class="el" href="classse_1_1_var.html#ac9961bf685e99775271001f063d30e74" title="Is symbolic expression defined?">is_symbolic()</a> returns true afterwards. This setter increments the version number by one each time it is called regardless of the supplied expression.</p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classse_1_1_abstract_value.html#aac1e89a0422b71366d4220b8886c46d1" title="Set the symbolic expression of the value.">AbstractValue::set_expr(const SharedExpr&amp;)</a> </dd></dl>

<p>Implements <a class="el" href="classse_1_1_abstract_var.html#ae49826e8823a7d31be918756c39f928b">se::AbstractVar</a>.</p>

</div>
</div>
<a class="anchor" id="a15e2a0dfcc0eb02ffad43513772d2697"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classse_1_1_var.html">se::Var</a>&lt; T &gt;::set_symbolic </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Force variable to be symbolic. </p>
<p>The supplied name must uniquely identify the newly created symbolic variable among the program's inputs.</p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classse_1_1_abstract_value.html#a6df191f56dd882c68a1cbf56cd9a7227" title="Force value to be symbolic.">AbstractValue::set_symbolic(const std::string&amp;)</a> </dd></dl>

<p>Implements <a class="el" href="classse_1_1_abstract_var.html#a69a22cdd0c27397f88d4eb620aa674c5">se::AbstractVar</a>.</p>

</div>
</div>
<a class="anchor" id="a730795296d4eb08e9929f46f0705f086"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classse_1_1_var.html">se::Var</a>&lt; T &gt;::stash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Save internal state. </p>
<p>All version information remains unaffected by this call. </p>

<p>Implements <a class="el" href="classse_1_1_abstract_var.html#adac6b70add5a560b3579fe266316eb2e">se::AbstractVar</a>.</p>

</div>
</div>
<a class="anchor" id="af04cbe42946832a5af846d4b8a292322"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacese.html#a7970802251b211c565f656366346d60f">Type</a> <a class="el" href="classse_1_1_var.html">se::Var</a>&lt; T &gt;::type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>type information </p>
<p>Note that any precision loss that might have occurred due to type casting is conservatively approximated by <a class="el" href="classse_1_1_var.html#a775bb1830c000d3949f3059af0dff9e0" title="Is concrete or symbolic value subject to an up or down cast?">is_cast()</a>.</p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classse_1_1_abstract_value.html#a4ab99a36058d20524845cda51be197d4" title="type information">AbstractValue::type()</a> </dd></dl>

<p>Implements <a class="el" href="classse_1_1_abstract_var.html#a26ce405296881a40a435c441e0431601">se::AbstractVar</a>.</p>

</div>
</div>
<a class="anchor" id="acef96fa94c498b655f99eb36f156218e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classse_1_1_var.html">se::Var</a>&lt; T &gt;::unstash </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restore internal state (i.e. reverse <a class="el" href="classse_1_1_var.html#a730795296d4eb08e9929f46f0705f086" title="Save internal state.">stash()</a>) </p>
<p><code>unstash(true)</code> restores the most recently stashed internal variable state. It also deallocates all the resources which stored this internal state. The variable's version number is incremented by one if and only if it has been modified since the most recent <a class="el" href="classse_1_1_var.html#a730795296d4eb08e9929f46f0705f086" title="Save internal state.">stash()</a> call.</p>
<p>In contrast, <code>unstash(false)</code> only deallocates resources acquired by the most recent <a class="el" href="classse_1_1_var.html#a730795296d4eb08e9929f46f0705f086" title="Save internal state.">stash()</a> call; the internal variable state remains unaffected. Thus, the versioning information never changes when the flag is false.</p>
<p>Regardless of the flag value, it is a programmer error to call <a class="el" href="classse_1_1_var.html#acef96fa94c498b655f99eb36f156218e" title="Restore internal state (i.e. reverse stash())">unstash(bool)</a> more times than <a class="el" href="classse_1_1_var.html#a730795296d4eb08e9929f46f0705f086" title="Save internal state.">stash()</a> has been invoked. </p>

<p>Implements <a class="el" href="classse_1_1_abstract_var.html#a40ddeeb6f46c411c880e28f7cca5fb08">se::AbstractVar</a>.</p>

</div>
</div>
<a class="anchor" id="a73b0dc037906ce363dbf81a07ec86c19"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classse_1_1_value.html">Value</a>&lt;T&gt;&amp; <a class="el" href="classse_1_1_var.html">se::Var</a>&lt; T &gt;::value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concrete/symbolic value. </p>
<p>Read-only reference to an object that contains the concrete value and runtime information about this variable. The caller must ensure that it does not dereference the return value after this object has been destroyed.</p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classse_1_1_value.html" title="Type-safe (symbolic/concrete) lvalue.">Value</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa577b2f7974dbdf6b302783b21a0dbd5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacese.html#a39a431ff182bfd5e6480bb197ca64f3a">Version</a> <a class="el" href="classse_1_1_var.html">se::Var</a>&lt; T &gt;::version </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-decreasing number which increments with every assignment. </p>
<p>How often has the variable been assigned a new value or a symbolic expression? </p>

<p>Implements <a class="el" href="classse_1_1_abstract_var.html#aa5dc9dfb47e032d5b2f02d2e288abc37">se::AbstractVar</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/<a class="el" href="var_8h_source.html">var.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Sep 16 2012 17:15:28 for libse by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.1
</small></address>
</body>
</html>
