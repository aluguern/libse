<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>libse: se::Value&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libse
   &#160;<span id="projectnumber">0.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacese.html">se</a></li><li class="navelem"><a class="el" href="classse_1_1_value.html">Value</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">se::Value&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Type-safe (symbolic/concrete) lvalue.  
 <a href="classse_1_1_value.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="value_8h_source.html">value.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for se::Value&lt; T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classse_1_1_value.png" usemap="#se::Value&lt; T &gt;_map" alt=""/>
  <map id="se::Value&lt; T &gt;_map" name="se::Value&lt; T &gt;_map">
<area href="classse_1_1_abstract_value.html" title="Base class for a (symbolic/concrete) lvalue." alt="se::AbstractValue" shape="rect" coords="0,0,111,24"/>
</map>
 </div></div>

<p><a href="classse_1_1_value-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a55e46794f83f68ca3b5a20391b9300bd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_value.html#a55e46794f83f68ca3b5a20391b9300bd">Value</a> (const T <a class="el" href="classse_1_1_value.html#a0ec876bceff3ab3bb3836d0e7a958025">value</a>)</td></tr>
<tr class="memdesc:a55e46794f83f68ca3b5a20391b9300bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete value for multi-path and single-path symbolic execution.  <a href="#a55e46794f83f68ca3b5a20391b9300bd"></a><br/></td></tr>
<tr class="memitem:a71d7930a8d6b289c6df22982f4e86fd0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_value.html#a71d7930a8d6b289c6df22982f4e86fd0">Value</a> (const T <a class="el" href="classse_1_1_value.html#a0ec876bceff3ab3bb3836d0e7a958025">value</a>, const <a class="el" href="namespacese.html#a594ed393deaf50eee0630623a84ab9bb">SharedExpr</a> &amp;<a class="el" href="classse_1_1_value.html#a52aabda27df3fc20626c271cc6b27e56">expr</a>)</td></tr>
<tr class="memdesc:a71d7930a8d6b289c6df22982f4e86fd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concolic value for multi-path and single-path symbolic execution.  <a href="#a71d7930a8d6b289c6df22982f4e86fd0"></a><br/></td></tr>
<tr class="memitem:a71b9290ba95f7ab602bb6619d39156dc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_value.html#a71b9290ba95f7ab602bb6619d39156dc">Value</a> (const std::string &amp;identifier)</td></tr>
<tr class="memdesc:a71b9290ba95f7ab602bb6619d39156dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arbitrary value only for multi-path symbolic execution.  <a href="#a71b9290ba95f7ab602bb6619d39156dc"></a><br/></td></tr>
<tr class="memitem:a5895e9736000228b8cf946aac449a178"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5895e9736000228b8cf946aac449a178"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_value.html#a5895e9736000228b8cf946aac449a178">Value</a> (const <a class="el" href="classse_1_1_value.html">Value</a> &amp;other)</td></tr>
<tr class="memdesc:a5895e9736000228b8cf946aac449a178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy any concrete data and symbolic expression. <br/></td></tr>
<tr class="memitem:a21276f925e009c8a7692616ff316e18b"><td class="memTemplParams" colspan="2">template&lt;typename S &gt; </td></tr>
<tr class="memitem:a21276f925e009c8a7692616ff316e18b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classse_1_1_value.html#a21276f925e009c8a7692616ff316e18b">Value</a> (const <a class="el" href="classse_1_1_value.html">Value</a>&lt; S &gt; &amp;)</td></tr>
<tr class="memdesc:a21276f925e009c8a7692616ff316e18b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy conversion constructor with type casting.  <a href="#a21276f925e009c8a7692616ff316e18b"></a><br/></td></tr>
<tr class="memitem:ad7e383845b5e48e3f08052bf7f47fefb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_value.html#ad7e383845b5e48e3f08052bf7f47fefb">has_aux_value</a> () const </td></tr>
<tr class="memdesc:ad7e383845b5e48e3f08052bf7f47fefb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is symbolic expression simplified through constant propagation?  <a href="#ad7e383845b5e48e3f08052bf7f47fefb"></a><br/></td></tr>
<tr class="memitem:a57fa6bc1ed2ed40272daf6afbf0608f3"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_value.html#a57fa6bc1ed2ed40272daf6afbf0608f3">aux_value</a> () const </td></tr>
<tr class="memdesc:a57fa6bc1ed2ed40272daf6afbf0608f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current result of constant propagation (if defined)  <a href="#a57fa6bc1ed2ed40272daf6afbf0608f3"></a><br/></td></tr>
<tr class="memitem:a84aba5264eae2d71990973666b05f68b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_value.html#a84aba5264eae2d71990973666b05f68b">set_aux_value</a> (const T v)</td></tr>
<tr class="memdesc:a84aba5264eae2d71990973666b05f68b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set constant propagation value.  <a href="#a84aba5264eae2d71990973666b05f68b"></a><br/></td></tr>
<tr class="memitem:a0ec876bceff3ab3bb3836d0e7a958025"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_value.html#a0ec876bceff3ab3bb3836d0e7a958025">value</a> () const </td></tr>
<tr class="memdesc:a0ec876bceff3ab3bb3836d0e7a958025"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete data (if defined)  <a href="#a0ec876bceff3ab3bb3836d0e7a958025"></a><br/></td></tr>
<tr class="memitem:af038215019d95fb79279ca96de15dcaf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_value.html#af038215019d95fb79279ca96de15dcaf">set_symbolic</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:af038215019d95fb79279ca96de15dcaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force value to be symbolic.  <a href="#af038215019d95fb79279ca96de15dcaf"></a><br/></td></tr>
<tr class="memitem:ab7cc4e2124a076ed32358de347237815"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7cc4e2124a076ed32358de347237815"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_value.html#ab7cc4e2124a076ed32358de347237815">write</a> (std::ostream &amp;) const </td></tr>
<tr class="memdesc:ab7cc4e2124a076ed32358de347237815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize concrete data and/or symbolic expression. <br/></td></tr>
<tr class="memitem:a52aabda27df3fc20626c271cc6b27e56"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacese.html#a594ed393deaf50eee0630623a84ab9bb">SharedExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_value.html#a52aabda27df3fc20626c271cc6b27e56">expr</a> () const </td></tr>
<tr class="memdesc:a52aabda27df3fc20626c271cc6b27e56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplified symbolic expression (if defined)  <a href="#a52aabda27df3fc20626c271cc6b27e56"></a><br/></td></tr>
<tr class="memitem:ac22574c59a9ed38866b6b5466e66729e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classse_1_1_value.html">Value</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_value.html#ac22574c59a9ed38866b6b5466e66729e">operator=</a> (const <a class="el" href="classse_1_1_value.html">Value</a> &amp;other)</td></tr>
<tr class="memdesc:ac22574c59a9ed38866b6b5466e66729e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace concrete data and shared symbolic expression.  <a href="#ac22574c59a9ed38866b6b5466e66729e"></a><br/></td></tr>
<tr class="memitem:a6890d434413966b00e0c5b21bc236edf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_value.html#a6890d434413966b00e0c5b21bc236edf">operator T</a> () const </td></tr>
<tr class="memdesc:a6890d434413966b00e0c5b21bc236edf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete data (if defined)  <a href="#a6890d434413966b00e0c5b21bc236edf"></a><br/></td></tr>
<tr class="inherit_header pub_methods_classse_1_1_abstract_value"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classse_1_1_abstract_value')"><img src="closed.png" alt="-"/>&nbsp;Public Member Functions inherited from <a class="el" href="classse_1_1_abstract_value.html">se::AbstractValue</a></td></tr>
<tr class="memitem:a4ab99a36058d20524845cda51be197d4 inherit pub_methods_classse_1_1_abstract_value"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacese.html#a7970802251b211c565f656366346d60f">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_abstract_value.html#a4ab99a36058d20524845cda51be197d4">type</a> () const </td></tr>
<tr class="memdesc:a4ab99a36058d20524845cda51be197d4 inherit pub_methods_classse_1_1_abstract_value"><td class="mdescLeft">&#160;</td><td class="mdescRight">type information  <a href="#a4ab99a36058d20524845cda51be197d4"></a><br/></td></tr>
<tr class="memitem:a285c2bc007864c01d82191234b6a0c26 inherit pub_methods_classse_1_1_abstract_value"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_abstract_value.html#a285c2bc007864c01d82191234b6a0c26">is_symbolic</a> () const </td></tr>
<tr class="memdesc:a285c2bc007864c01d82191234b6a0c26 inherit pub_methods_classse_1_1_abstract_value"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is symbolic expression defined?  <a href="#a285c2bc007864c01d82191234b6a0c26"></a><br/></td></tr>
<tr class="memitem:ae7b88cb20bf1b639c14f25d5cc10de4e inherit pub_methods_classse_1_1_abstract_value"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_abstract_value.html#ae7b88cb20bf1b639c14f25d5cc10de4e">is_concrete</a> () const </td></tr>
<tr class="memdesc:ae7b88cb20bf1b639c14f25d5cc10de4e inherit pub_methods_classse_1_1_abstract_value"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is concrete data defined?  <a href="#ae7b88cb20bf1b639c14f25d5cc10de4e"></a><br/></td></tr>
<tr class="memitem:aac1e89a0422b71366d4220b8886c46d1 inherit pub_methods_classse_1_1_abstract_value"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_abstract_value.html#aac1e89a0422b71366d4220b8886c46d1">set_expr</a> (const <a class="el" href="namespacese.html#a594ed393deaf50eee0630623a84ab9bb">SharedExpr</a> &amp;<a class="el" href="classse_1_1_abstract_value.html#a6cc055fb16a0b65cf889532c2b6b7629">expr</a>)</td></tr>
<tr class="memdesc:aac1e89a0422b71366d4220b8886c46d1 inherit pub_methods_classse_1_1_abstract_value"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the symbolic expression of the value.  <a href="#aac1e89a0422b71366d4220b8886c46d1"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classse_1_1_abstract_value"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classse_1_1_abstract_value')"><img src="closed.png" alt="-"/>&nbsp;Protected Member Functions inherited from <a class="el" href="classse_1_1_abstract_value.html">se::AbstractValue</a></td></tr>
<tr class="memitem:a5af0b88e9ef5259985db91b3724fb218 inherit pro_methods_classse_1_1_abstract_value"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_abstract_value.html#a5af0b88e9ef5259985db91b3724fb218">AbstractValue</a> (const <a class="el" href="namespacese.html#a7970802251b211c565f656366346d60f">Type</a> <a class="el" href="classse_1_1_abstract_value.html#a4ab99a36058d20524845cda51be197d4">type</a>, bool concolic)</td></tr>
<tr class="memdesc:a5af0b88e9ef5259985db91b3724fb218 inherit pro_methods_classse_1_1_abstract_value"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete value with type information.  <a href="#a5af0b88e9ef5259985db91b3724fb218"></a><br/></td></tr>
<tr class="memitem:af10074034121d349d24869279c9d09f0 inherit pro_methods_classse_1_1_abstract_value"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_abstract_value.html#af10074034121d349d24869279c9d09f0">AbstractValue</a> (const <a class="el" href="namespacese.html#a7970802251b211c565f656366346d60f">Type</a> <a class="el" href="classse_1_1_abstract_value.html#a4ab99a36058d20524845cda51be197d4">type</a>, const <a class="el" href="namespacese.html#a594ed393deaf50eee0630623a84ab9bb">SharedExpr</a> <a class="el" href="classse_1_1_abstract_value.html#a6cc055fb16a0b65cf889532c2b6b7629">expr</a>, bool concolic)</td></tr>
<tr class="memdesc:af10074034121d349d24869279c9d09f0 inherit pro_methods_classse_1_1_abstract_value"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete value with type information and symbolic expression.  <a href="#af10074034121d349d24869279c9d09f0"></a><br/></td></tr>
<tr class="memitem:a30ced39ffe050a6f50e4f8bb096968a4 inherit pro_methods_classse_1_1_abstract_value"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_abstract_value.html#a30ced39ffe050a6f50e4f8bb096968a4">AbstractValue</a> (const <a class="el" href="classse_1_1_abstract_value.html">AbstractValue</a> &amp;other)</td></tr>
<tr class="memdesc:a30ced39ffe050a6f50e4f8bb096968a4 inherit pro_methods_classse_1_1_abstract_value"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy type information and symbolic expression (if any)  <a href="#a30ced39ffe050a6f50e4f8bb096968a4"></a><br/></td></tr>
<tr class="memitem:ae06867253abd42df268eb90b579b556e inherit pro_methods_classse_1_1_abstract_value"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classse_1_1_abstract_value.html">AbstractValue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_abstract_value.html#ae06867253abd42df268eb90b579b556e">operator=</a> (const <a class="el" href="classse_1_1_abstract_value.html">AbstractValue</a> &amp;other)</td></tr>
<tr class="memdesc:ae06867253abd42df268eb90b579b556e inherit pro_methods_classse_1_1_abstract_value"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace symbolic expression.  <a href="#ae06867253abd42df268eb90b579b556e"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br/>
class se::Value&lt; T &gt;</h3>

<p>Type-safe (symbolic/concrete) lvalue. </p>
<p>A <a class="el" href="classse_1_1_abstract_value.html#a285c2bc007864c01d82191234b6a0c26">symbolic</a> value of type T can be created with <a class="el" href="namespacese.html#a30ce74f589841461c6b57071ea4b36e4" title="Create a symbolic value of type T.">any(const std::string&amp;)</a>.</p>
<p>In contrast, a <a class="el" href="classse_1_1_abstract_value.html#ae7b88cb20bf1b639c14f25d5cc10de4e">concrete</a> value of type T can be created with <a class="el" href="namespacese.html#a78eaad60b7258f63ad85a61577f61d87" title="Create concrete value for multi-path and single-path symbolic execution.">make_value(const T)</a>. In addition, an assignment or instantiation with concrete data always yields concrete value. A concrete value can be also made symbolic by calling <a class="el" href="classse_1_1_value.html#af038215019d95fb79279ca96de15dcaf" title="Force value to be symbolic.">set_symbolic(const std::string&amp;)</a> on it.</p>
<p>More generally, if <a class="el" href="classse_1_1_abstract_value.html#ae7b88cb20bf1b639c14f25d5cc10de4e" title="Is concrete data defined?">AbstractValue::is_concrete()</a>, the concrete data returned by <a class="el" href="classse_1_1_value.html#a0ec876bceff3ab3bb3836d0e7a958025" title="Concrete data (if defined)">Value&lt;T&gt;::value()</a> must be consistent with the program semantics of the program under test. This allows such a value to be used for single-path (i.e. DART-style) symbolic execution. Recall that this is also known as concolic execution. To facilitate this, the class implements an implicit T() type conversion operator. This conversion is standard except for the bool() case which also adds the value's symbolic expression to the list of <a class="el" href="namespacese.html#a60858c861e7e74961d121ce4fd5ef5bf">path constraints</a>. Thus, the use of non-bool types in control-flow such as <code>if (i + 5) {...}</code> is unsupported in concolic execution.</p>
<p><a class="el" href="classse_1_1_if.html" title="Control-flow annotation for multi-path symbolic execution of an if-then-else statement.">If</a> <a class="el" href="classse_1_1_value.html#ad7e383845b5e48e3f08052bf7f47fefb" title="Is symbolic expression simplified through constant propagation?">has_aux_value()</a> is true, then <a class="el" href="classse_1_1_value.html#a57fa6bc1ed2ed40272daf6afbf0608f3" title="Current result of constant propagation (if defined)">aux_value()</a> returns concrete data which is the result of constant propagation in the value's nary expression over an associative and commutative binary operator.</p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="namespacese.html#a30ce74f589841461c6b57071ea4b36e4" title="Create a symbolic value of type T.">any(const std::string&amp;)</a> </dd>
<dd>
<a class="el" href="namespacese.html#a78eaad60b7258f63ad85a61577f61d87" title="Create concrete value for multi-path and single-path symbolic execution.">make_value(const T)</a> </dd></dl>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a55e46794f83f68ca3b5a20391b9300bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classse_1_1_value.html">se::Value</a>&lt; T &gt;::<a class="el" href="classse_1_1_value.html">Value</a> </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concrete value for multi-path and single-path symbolic execution. </p>
<p>Initially, there is no symbolic expression associated with the value. The auxiliary value is undefined until <a class="el" href="classse_1_1_value.html#a84aba5264eae2d71990973666b05f68b" title="Set constant propagation value.">set_aux_value(const T)</a> is called. </p>

</div>
</div>
<a class="anchor" id="a71d7930a8d6b289c6df22982f4e86fd0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classse_1_1_value.html">se::Value</a>&lt; T &gt;::<a class="el" href="classse_1_1_value.html">Value</a> </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacese.html#a594ed393deaf50eee0630623a84ab9bb">SharedExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concolic value for multi-path and single-path symbolic execution. </p>
<p>The auxiliary value is undefined until <a class="el" href="classse_1_1_value.html#a84aba5264eae2d71990973666b05f68b" title="Set constant propagation value.">set_aux_value(const T)</a> is called. </p>

</div>
</div>
<a class="anchor" id="a71b9290ba95f7ab602bb6619d39156dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classse_1_1_value.html">se::Value</a>&lt; T &gt;::<a class="el" href="classse_1_1_value.html">Value</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Arbitrary value only for multi-path symbolic execution. </p>
<p>Since the value does not support implicit type conversions, it is only suitable for multi-path symbolic execution. Unless a concrete value is assigned to it later, <a class="el" href="classse_1_1_value.html#a0ec876bceff3ab3bb3836d0e7a958025" title="Concrete data (if defined)">value()</a> is undefined. Also <a class="el" href="classse_1_1_value.html#a57fa6bc1ed2ed40272daf6afbf0608f3" title="Current result of constant propagation (if defined)">aux_value()</a> is undefined until <a class="el" href="classse_1_1_value.html#a84aba5264eae2d71990973666b05f68b" title="Set constant propagation value.">set_aux_value(const T)</a> is called. </p>

</div>
</div>
<a class="anchor" id="a21276f925e009c8a7692616ff316e18b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classse_1_1_value.html">se::Value</a>&lt; T &gt;::<a class="el" href="classse_1_1_value.html">Value</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classse_1_1_value.html">Value</a>&lt; S &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy conversion constructor with type casting. </p>
<p>Copy auxiliary and primary value of another type. Since this requires a type conversion, precision could be lost. However, if the other value is symbolic, the type cast is explicit in form of a <a class="el" href="classse_1_1_cast_expr.html" title="Type cast of another symbolic expression.">CastExpr</a>. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a57fa6bc1ed2ed40272daf6afbf0608f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classse_1_1_value.html">se::Value</a>&lt; T &gt;::aux_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Current result of constant propagation (if defined) </p>
<p>Auxiliary value is defined if and only if <a class="el" href="classse_1_1_value.html#ad7e383845b5e48e3f08052bf7f47fefb" title="Is symbolic expression simplified through constant propagation?">has_aux_value()</a> is true. It implements constant propagation to simplify the value's <a class="el" href="classse_1_1_value.html#a52aabda27df3fc20626c271cc6b27e56">symbolic expression</a> if it is an <a class="el" href="classse_1_1_nary_expr.html" title="Operator with several operands.">NaryExpr</a> over an <a class="el" href="classse_1_1_nary_expr.html#abab9f2809694083c33b03cbf5b4d2cd2">associative</a> and <a class="el" href="classse_1_1_nary_expr.html#a879c8917e3367b619cb8a5a4153266c7">commutative</a> binary operator.</p>
<p>Thus, if <a class="el" href="classse_1_1_value.html#ad7e383845b5e48e3f08052bf7f47fefb" title="Is symbolic expression simplified through constant propagation?">has_aux_value()</a> is true, then <a class="el" href="classse_1_1_abstract_value.html#a285c2bc007864c01d82191234b6a0c26" title="Is symbolic expression defined?">is_symbolic()</a> is true. Yet, <a class="el" href="classse_1_1_abstract_value.html#ae7b88cb20bf1b639c14f25d5cc10de4e" title="Is concrete data defined?">is_concrete()</a> can be false. In that case, the concrete data is interpreted as the identity element of the nary operator.</p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classse_1_1_value.html#ad7e383845b5e48e3f08052bf7f47fefb" title="Is symbolic expression simplified through constant propagation?">has_aux_value()</a> </dd>
<dd>
<a class="el" href="classse_1_1_value.html#a84aba5264eae2d71990973666b05f68b" title="Set constant propagation value.">set_aux_value(const T)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a52aabda27df3fc20626c271cc6b27e56"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacese.html#a594ed393deaf50eee0630623a84ab9bb">SharedExpr</a> <a class="el" href="classse_1_1_value.html">se::Value</a>&lt; T &gt;::expr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simplified symbolic expression (if defined) </p>
<p>Unlike <a class="el" href="classse_1_1_abstract_value.html#a6cc055fb16a0b65cf889532c2b6b7629" title="Unsimplified symbolic expression.">AbstractValue::expr()</a>, <a class="el" href="classse_1_1_value.html#a52aabda27df3fc20626c271cc6b27e56" title="Simplified symbolic expression (if defined)">Value&lt;T&gt;::expr()</a> seeks to simplify an nary expression over an associative and commutative binary operator. This simplification is implemented through a <a class="el" href="classse_1_1_nary_expr.html#a1d3fb64f45564f9c8376f15e5153ee1d">partial nary expression</a> which is completed using the <a class="el" href="classse_1_1_value.html#a57fa6bc1ed2ed40272daf6afbf0608f3" title="Current result of constant propagation (if defined)">aux_value()</a>. For example, a symbolic expression such as "x + 2 + 3" would set <a class="el" href="classse_1_1_value.html#a57fa6bc1ed2ed40272daf6afbf0608f3" title="Current result of constant propagation (if defined)">aux_value()</a> <a class="el" href="classse_1_1_value.html#a57fa6bc1ed2ed40272daf6afbf0608f3" title="Current result of constant propagation (if defined)">aux_value()</a> to five (5 = 2 + 3). Then, <a class="el" href="classse_1_1_value.html#a52aabda27df3fc20626c271cc6b27e56" title="Simplified symbolic expression (if defined)">expr()</a> would return a <a class="el" href="namespacese.html#a594ed393deaf50eee0630623a84ab9bb">SharedExpr</a> to a new immutable <a class="el" href="classse_1_1_nary_expr.html" title="Operator with several operands.">NaryExpr</a> of the form "x + 5".</p>
<p>For this reason, if <a class="el" href="classse_1_1_value.html#a52aabda27df3fc20626c271cc6b27e56" title="Simplified symbolic expression (if defined)">expr()</a> returns a partial nary expression, then <a class="el" href="classse_1_1_value.html#ad7e383845b5e48e3f08052bf7f47fefb" title="Is symbolic expression simplified through constant propagation?">has_aux_value()</a> returns true. </p>

<p>Reimplemented from <a class="el" href="classse_1_1_abstract_value.html#a6cc055fb16a0b65cf889532c2b6b7629">se::AbstractValue</a>.</p>

</div>
</div>
<a class="anchor" id="ad7e383845b5e48e3f08052bf7f47fefb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classse_1_1_value.html">se::Value</a>&lt; T &gt;::has_aux_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is symbolic expression simplified through constant propagation? </p>
<p>true if and only if <a class="el" href="classse_1_1_value.html#a84aba5264eae2d71990973666b05f68b" title="Set constant propagation value.">set_aux_value(const T)</a> has been called at least once.</p>
<dl class="section remark"><dt>Remarks:</dt><dd>if <a class="el" href="classse_1_1_value.html#a52aabda27df3fc20626c271cc6b27e56" title="Simplified symbolic expression (if defined)">expr()</a> returns a <a class="el" href="classse_1_1_nary_expr.html#a1d3fb64f45564f9c8376f15e5153ee1d">partial nary expression</a>, then <a class="el" href="classse_1_1_value.html#ad7e383845b5e48e3f08052bf7f47fefb" title="Is symbolic expression simplified through constant propagation?">has_aux_value()</a> is true.</dd></dl>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classse_1_1_value.html#a57fa6bc1ed2ed40272daf6afbf0608f3" title="Current result of constant propagation (if defined)">aux_value()</a> </dd>
<dd>
<a class="el" href="classse_1_1_value.html#a84aba5264eae2d71990973666b05f68b" title="Set constant propagation value.">set_aux_value(const T)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6890d434413966b00e0c5b21bc236edf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classse_1_1_value.html">se::Value</a>&lt; T &gt;::operator T </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concrete data (if defined) </p>
<p>The return value is defined if and only if <a class="el" href="classse_1_1_abstract_value.html#ae7b88cb20bf1b639c14f25d5cc10de4e" title="Is concrete data defined?">is_concrete()</a> is true. Note that if <a class="el" href="classse_1_1_abstract_value.html#a285c2bc007864c01d82191234b6a0c26" title="Is symbolic expression defined?">is_symbolic()</a> is true, the conversion could render concolic execution incomplete.</p>
<p>Since C++ supports implicit primitive type conversions, this conversion operator is not explicit. Note that the bool() conversion operator adds the symbolic expression to the path constraints if and only if <a class="el" href="classse_1_1_abstract_value.html#a285c2bc007864c01d82191234b6a0c26" title="Is symbolic expression defined?">is_symbolic()</a> returns true.</p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classse_1_1_abstract_value.html#ae7b88cb20bf1b639c14f25d5cc10de4e" title="Is concrete data defined?">is_concrete()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac22574c59a9ed38866b6b5466e66729e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classse_1_1_value.html">Value</a>&amp; <a class="el" href="classse_1_1_value.html">se::Value</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classse_1_1_value.html">Value</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace concrete data and shared symbolic expression. </p>
<p>Assignment operator copies the concrete data and shared symbolic expression of the other value. Since the assignment usually involves a temporary value, no self-assignment check is performed. </p>

</div>
</div>
<a class="anchor" id="a84aba5264eae2d71990973666b05f68b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classse_1_1_value.html">se::Value</a>&lt; T &gt;::set_aux_value </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set constant propagation value. </p>
<p>Since <a class="el" href="classse_1_1_value.html#a57fa6bc1ed2ed40272daf6afbf0608f3" title="Current result of constant propagation (if defined)">aux_value()</a> is meant to simplify the value's <a class="el" href="classse_1_1_value.html#a52aabda27df3fc20626c271cc6b27e56">symbolic expression</a>, <a class="el" href="classse_1_1_abstract_value.html#a285c2bc007864c01d82191234b6a0c26" title="Is symbolic expression defined?">is_symbolic()</a> must be true when calling <a class="el" href="classse_1_1_value.html#a84aba5264eae2d71990973666b05f68b" title="Set constant propagation value.">set_aux_value(const T)</a>.</p>
<dl class="section remark"><dt>Remarks:</dt><dd><a class="el" href="classse_1_1_value.html#ad7e383845b5e48e3f08052bf7f47fefb" title="Is symbolic expression simplified through constant propagation?">has_aux_value()</a> returns true afterwards </dd></dl>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classse_1_1_value.html#a57fa6bc1ed2ed40272daf6afbf0608f3" title="Current result of constant propagation (if defined)">aux_value()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af038215019d95fb79279ca96de15dcaf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classse_1_1_value.html">se::Value</a>&lt; T &gt;::set_symbolic </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Force value to be symbolic. </p>
<p>Create symbolic value by either creating a new <a class="el" href="classse_1_1_any_expr.html" title="Type-safe symbolic variable of an arbitrary value.">AnyExpr</a> or <a class="el" href="classse_1_1_value_expr.html" title="Type-safe concrete value with an optional symbolic value.">ValueExpr</a>. The choice depends on <a class="el" href="classse_1_1_abstract_value.html#ae7b88cb20bf1b639c14f25d5cc10de4e" title="Is concrete data defined?">is_concrete()</a>. </p>

<p>Implements <a class="el" href="classse_1_1_abstract_value.html#a6df191f56dd882c68a1cbf56cd9a7227">se::AbstractValue</a>.</p>

</div>
</div>
<a class="anchor" id="a0ec876bceff3ab3bb3836d0e7a958025"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classse_1_1_value.html">se::Value</a>&lt; T &gt;::value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concrete data (if defined) </p>
<p>Concrete data is defined if and only if <a class="el" href="classse_1_1_abstract_value.html#ae7b88cb20bf1b639c14f25d5cc10de4e" title="Is concrete data defined?">is_concrete()</a> return true. </p>
<dl class="section remark"><dt>Remarks:</dt><dd>Concrete data can only be set through the assignment operator </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/<a class="el" href="value_8h_source.html">value.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Sep 16 2012 17:15:28 for libse by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.1
</small></address>
</body>
</html>
