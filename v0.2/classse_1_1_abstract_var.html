<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>libse: se::AbstractVar Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libse
   &#160;<span id="projectnumber">0.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacese.html">se</a></li><li class="navelem"><a class="el" href="classse_1_1_abstract_var.html">AbstractVar</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">se::AbstractVar Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Base class for a (symbolic/concrete) lvalue.  
 <a href="classse_1_1_abstract_var.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="var_8h_source.html">var.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for se::AbstractVar:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classse_1_1_abstract_var.png" usemap="#se::AbstractVar_map" alt=""/>
  <map id="se::AbstractVar_map" name="se::AbstractVar_map">
<area href="classse_1_1_var.html" title="Type-safe (symbolic/concrete) rvalue." alt="se::Var&lt; T &gt;" shape="rect" coords="0,56,99,80"/>
</map>
 </div></div>

<p><a href="classse_1_1_abstract_var-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a26ce405296881a40a435c441e0431601"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacese.html#a7970802251b211c565f656366346d60f">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_abstract_var.html#a26ce405296881a40a435c441e0431601">type</a> () const =0</td></tr>
<tr class="memdesc:a26ce405296881a40a435c441e0431601"><td class="mdescLeft">&#160;</td><td class="mdescRight">type information  <a href="#a26ce405296881a40a435c441e0431601"></a><br/></td></tr>
<tr class="memitem:a00fc2e78cbb1c1e8e118fe7000c8fa07"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_abstract_var.html#a00fc2e78cbb1c1e8e118fe7000c8fa07">is_cast</a> () const =0</td></tr>
<tr class="memdesc:a00fc2e78cbb1c1e8e118fe7000c8fa07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is concrete or symbolic value subject to an up or down cast?  <a href="#a00fc2e78cbb1c1e8e118fe7000c8fa07"></a><br/></td></tr>
<tr class="memitem:a69a22cdd0c27397f88d4eb620aa674c5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_abstract_var.html#a69a22cdd0c27397f88d4eb620aa674c5">set_symbolic</a> (const std::string &amp;identifier)=0</td></tr>
<tr class="memdesc:a69a22cdd0c27397f88d4eb620aa674c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force variable to be symbolic.  <a href="#a69a22cdd0c27397f88d4eb620aa674c5"></a><br/></td></tr>
<tr class="memitem:ada33e409d05ecb7670d67b517b9c53a9"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_abstract_var.html#ada33e409d05ecb7670d67b517b9c53a9">is_symbolic</a> () const =0</td></tr>
<tr class="memdesc:ada33e409d05ecb7670d67b517b9c53a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is symbolic expression defined?  <a href="#ada33e409d05ecb7670d67b517b9c53a9"></a><br/></td></tr>
<tr class="memitem:a45e5dfdeac76bb372bcf81d45c8f0037"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_abstract_var.html#a45e5dfdeac76bb372bcf81d45c8f0037">is_concrete</a> () const =0</td></tr>
<tr class="memdesc:a45e5dfdeac76bb372bcf81d45c8f0037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is concrete data defined?  <a href="#a45e5dfdeac76bb372bcf81d45c8f0037"></a><br/></td></tr>
<tr class="memitem:aa5dc9dfb47e032d5b2f02d2e288abc37"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacese.html#a39a431ff182bfd5e6480bb197ca64f3a">Version</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_abstract_var.html#aa5dc9dfb47e032d5b2f02d2e288abc37">version</a> () const =0</td></tr>
<tr class="memdesc:aa5dc9dfb47e032d5b2f02d2e288abc37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-decreasing number which increments with every assignment.  <a href="#aa5dc9dfb47e032d5b2f02d2e288abc37"></a><br/></td></tr>
<tr class="memitem:ae49826e8823a7d31be918756c39f928b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_abstract_var.html#ae49826e8823a7d31be918756c39f928b">set_expr</a> (const <a class="el" href="namespacese.html#a594ed393deaf50eee0630623a84ab9bb">SharedExpr</a> &amp;)=0</td></tr>
<tr class="memdesc:ae49826e8823a7d31be918756c39f928b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the symbolic expression of the variable.  <a href="#ae49826e8823a7d31be918756c39f928b"></a><br/></td></tr>
<tr class="memitem:aa6f6434d482f319bcf93b223d8373708"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="namespacese.html#a594ed393deaf50eee0630623a84ab9bb">SharedExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_abstract_var.html#aa6f6434d482f319bcf93b223d8373708">expr</a> () const =0</td></tr>
<tr class="memdesc:aa6f6434d482f319bcf93b223d8373708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression of the variable.  <a href="#aa6f6434d482f319bcf93b223d8373708"></a><br/></td></tr>
<tr class="memitem:adac6b70add5a560b3579fe266316eb2e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_abstract_var.html#adac6b70add5a560b3579fe266316eb2e">stash</a> ()=0</td></tr>
<tr class="memdesc:adac6b70add5a560b3579fe266316eb2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save internal state.  <a href="#adac6b70add5a560b3579fe266316eb2e"></a><br/></td></tr>
<tr class="memitem:a40ddeeb6f46c411c880e28f7cca5fb08"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classse_1_1_abstract_var.html#a40ddeeb6f46c411c880e28f7cca5fb08">unstash</a> (bool)=0</td></tr>
<tr class="memdesc:a40ddeeb6f46c411c880e28f7cca5fb08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore internal state (i.e. reverse <a class="el" href="classse_1_1_abstract_var.html#adac6b70add5a560b3579fe266316eb2e" title="Save internal state.">stash()</a>)  <a href="#a40ddeeb6f46c411c880e28f7cca5fb08"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Base class for a (symbolic/concrete) lvalue. </p>
<p>Base class for an lvalue with optional concrete data and an optional symbolic expression.</p>
<p>More precisely, the class can associate a C++ lvalue (locator value) with an algebraic expression in a certain theory. In the previous example, a C++ statement which increments a the symbolic variable <code>x</code> by three would could yield the symbolic expression "x + 3" in the ring of integers. By choosing an appropriate theory, the API can be used to successively approximate the strongest postcondition of a program variable. This is typically referred to as symbolic execution. The variable is suitable for multi-path symbolic execution only if if it <a class="el" href="classse_1_1_abstract_var.html#ada33e409d05ecb7670d67b517b9c53a9" title="Is symbolic expression defined?">is_symbolic()</a>. In addition, if it <a class="el" href="classse_1_1_abstract_var.html#a45e5dfdeac76bb372bcf81d45c8f0037" title="Is concrete data defined?">is_concrete()</a>, then it can be used in single-path symbolic execution.</p>
<p>Therefore, an <a class="el" href="classse_1_1_abstract_var.html" title="Base class for a (symbolic/concrete) lvalue.">AbstractVar</a> object's symbolic expression could be seen as a function on the program inputs. Thus, an assignment never irrevocably overwrites any information. This contrasts conventional assignments in imperative programming languages. For this reason, the API could be also useful for debugging purposes.</p>
<p>Changes to the variable are tracked by a version number. The version number is always initialized to zero. Subsequently, on each modifier operation, it is incremented by one. These version numbers are never based on the version information of another <a class="el" href="classse_1_1_abstract_var.html" title="Base class for a (symbolic/concrete) lvalue.">AbstractVar</a> object. This could simplify the use of the generating of dynamic single assignment (DSA) forms.</p>
<p>Except the version information, the internal state of a variable can be saved and restored with <a class="el" href="classse_1_1_abstract_var.html#adac6b70add5a560b3579fe266316eb2e" title="Save internal state.">stash()</a> and <a class="el" href="classse_1_1_abstract_var.html#a40ddeeb6f46c411c880e28f7cca5fb08">unstash(true)</a>, respectively. It is a programmer error to call <a class="el" href="classse_1_1_abstract_var.html#a40ddeeb6f46c411c880e28f7cca5fb08" title="Restore internal state (i.e. reverse stash())">unstash(bool)</a> more times than <a class="el" href="classse_1_1_abstract_var.html#adac6b70add5a560b3579fe266316eb2e" title="Save internal state.">stash()</a>. To conserve resources, every <a class="el" href="classse_1_1_abstract_var.html#adac6b70add5a560b3579fe266316eb2e" title="Save internal state.">stash()</a> call should be matched with a corresponding <a class="el" href="classse_1_1_abstract_var.html#a40ddeeb6f46c411c880e28f7cca5fb08" title="Restore internal state (i.e. reverse stash())">unstash(bool)</a> call (note that the flag value is irrelevant for resource deallocation purposes).</p>
<p>Finally, each implementation of the <a class="el" href="classse_1_1_abstract_var.html" title="Base class for a (symbolic/concrete) lvalue.">AbstractVar</a> interface must take type casting into account. These type casts should be explicit in a <a class="el" href="classse_1_1_abstract_var.html#aa6f6434d482f319bcf93b223d8373708">variable's symbolic expression</a>; the proper way of doing this is through <a class="el" href="classse_1_1_cast_expr.html" title="Type cast of another symbolic expression.">CastExpr</a>. </p>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aa6f6434d482f319bcf93b223d8373708"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="namespacese.html#a594ed393deaf50eee0630623a84ab9bb">SharedExpr</a> se::AbstractVar::expr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Symbolic expression of the variable. </p>
<p>The return value is a NULL pointer if and only if <a class="el" href="classse_1_1_abstract_var.html#ada33e409d05ecb7670d67b517b9c53a9" title="Is symbolic expression defined?">is_symbolic()</a> is false. /see <a class="el" href="classse_1_1_abstract_value.html#a6cc055fb16a0b65cf889532c2b6b7629" title="Unsimplified symbolic expression.">AbstractValue::expr()</a> </p>

<p>Implemented in <a class="el" href="classse_1_1_var.html#a05015d6ee9dfde7711e19aedb7ae7c2b">se::Var&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a00fc2e78cbb1c1e8e118fe7000c8fa07"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool se::AbstractVar::is_cast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is concrete or symbolic value subject to an up or down cast? </p>
<p><a class="el" href="classse_1_1_if.html" title="Control-flow annotation for multi-path symbolic execution of an if-then-else statement.">If</a> an unsafe type conversion is needed, then <a class="el" href="classse_1_1_abstract_var.html#a00fc2e78cbb1c1e8e118fe7000c8fa07" title="Is concrete or symbolic value subject to an up or down cast?">is_cast()</a> returns true. Note that the converse is false since <a class="el" href="classse_1_1_abstract_var.html#a00fc2e78cbb1c1e8e118fe7000c8fa07" title="Is concrete or symbolic value subject to an up or down cast?">is_cast()</a> also returns true for up casts. </p>

<p>Implemented in <a class="el" href="classse_1_1_var.html#a775bb1830c000d3949f3059af0dff9e0">se::Var&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a45e5dfdeac76bb372bcf81d45c8f0037"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool se::AbstractVar::is_concrete </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is concrete data defined? </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classse_1_1_abstract_value.html#ae7b88cb20bf1b639c14f25d5cc10de4e" title="Is concrete data defined?">AbstractValue::is_concrete()</a> </dd></dl>

<p>Implemented in <a class="el" href="classse_1_1_var.html#a87dc71b44618873a3cfe9c4053ae1cc2">se::Var&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ada33e409d05ecb7670d67b517b9c53a9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool se::AbstractVar::is_symbolic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is symbolic expression defined? </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classse_1_1_abstract_value.html#a285c2bc007864c01d82191234b6a0c26" title="Is symbolic expression defined?">AbstractValue::is_symbolic()</a> </dd>
<dd>
<a class="el" href="classse_1_1_abstract_value.html#a6cc055fb16a0b65cf889532c2b6b7629" title="Unsimplified symbolic expression.">AbstractValue::expr()</a> </dd></dl>

<p>Implemented in <a class="el" href="classse_1_1_var.html#ac9961bf685e99775271001f063d30e74">se::Var&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ae49826e8823a7d31be918756c39f928b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void se::AbstractVar::set_expr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacese.html#a594ed393deaf50eee0630623a84ab9bb">SharedExpr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the symbolic expression of the variable. </p>
<p>Unless the argument is NULL, <a class="el" href="classse_1_1_abstract_var.html#ada33e409d05ecb7670d67b517b9c53a9" title="Is symbolic expression defined?">is_symbolic()</a> returns true afterwards. This setter increments the version number by one each time it is called regardless of the supplied expression.</p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classse_1_1_abstract_value.html#aac1e89a0422b71366d4220b8886c46d1" title="Set the symbolic expression of the value.">AbstractValue::set_expr(const SharedExpr&amp;)</a> </dd></dl>

<p>Implemented in <a class="el" href="classse_1_1_var.html#a91fde7edd704200b1f288a8b6eb38748">se::Var&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a69a22cdd0c27397f88d4eb620aa674c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void se::AbstractVar::set_symbolic </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Force variable to be symbolic. </p>
<p>The supplied name must uniquely identify the newly created symbolic variable among the program's inputs.</p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classse_1_1_abstract_value.html#a6df191f56dd882c68a1cbf56cd9a7227" title="Force value to be symbolic.">AbstractValue::set_symbolic(const std::string&amp;)</a> </dd></dl>

<p>Implemented in <a class="el" href="classse_1_1_var.html#a15e2a0dfcc0eb02ffad43513772d2697">se::Var&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="adac6b70add5a560b3579fe266316eb2e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void se::AbstractVar::stash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Save internal state. </p>
<p>All version information remains unaffected by this call. </p>

<p>Implemented in <a class="el" href="classse_1_1_var.html#a730795296d4eb08e9929f46f0705f086">se::Var&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a26ce405296881a40a435c441e0431601"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacese.html#a7970802251b211c565f656366346d60f">Type</a> se::AbstractVar::type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>type information </p>
<p>Note that any precision loss that might have occurred due to type casting is conservatively approximated by <a class="el" href="classse_1_1_abstract_var.html#a00fc2e78cbb1c1e8e118fe7000c8fa07" title="Is concrete or symbolic value subject to an up or down cast?">is_cast()</a>.</p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classse_1_1_abstract_value.html#a4ab99a36058d20524845cda51be197d4" title="type information">AbstractValue::type()</a> </dd></dl>

<p>Implemented in <a class="el" href="classse_1_1_var.html#af04cbe42946832a5af846d4b8a292322">se::Var&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a40ddeeb6f46c411c880e28f7cca5fb08"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void se::AbstractVar::unstash </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restore internal state (i.e. reverse <a class="el" href="classse_1_1_abstract_var.html#adac6b70add5a560b3579fe266316eb2e" title="Save internal state.">stash()</a>) </p>
<p><code>unstash(true)</code> restores the most recently stashed internal variable state. It also deallocates all the resources which stored this internal state. The variable's version number is incremented by one if and only if it has been modified since the most recent <a class="el" href="classse_1_1_abstract_var.html#adac6b70add5a560b3579fe266316eb2e" title="Save internal state.">stash()</a> call.</p>
<p>In contrast, <code>unstash(false)</code> only deallocates resources acquired by the most recent <a class="el" href="classse_1_1_abstract_var.html#adac6b70add5a560b3579fe266316eb2e" title="Save internal state.">stash()</a> call; the internal variable state remains unaffected. Thus, the versioning information never changes when the flag is false.</p>
<p>Regardless of the flag value, it is a programmer error to call <a class="el" href="classse_1_1_abstract_var.html#a40ddeeb6f46c411c880e28f7cca5fb08" title="Restore internal state (i.e. reverse stash())">unstash(bool)</a> more times than <a class="el" href="classse_1_1_abstract_var.html#adac6b70add5a560b3579fe266316eb2e" title="Save internal state.">stash()</a> has been invoked. </p>

<p>Implemented in <a class="el" href="classse_1_1_var.html#acef96fa94c498b655f99eb36f156218e">se::Var&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aa5dc9dfb47e032d5b2f02d2e288abc37"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacese.html#a39a431ff182bfd5e6480bb197ca64f3a">Version</a> se::AbstractVar::version </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-decreasing number which increments with every assignment. </p>
<p>How often has the variable been assigned a new value or a symbolic expression? </p>

<p>Implemented in <a class="el" href="classse_1_1_var.html#aa577b2f7974dbdf6b302783b21a0dbd5">se::Var&lt; T &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/<a class="el" href="var_8h_source.html">var.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Sep 16 2012 17:15:28 for libse by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.1
</small></address>
</body>
</html>
